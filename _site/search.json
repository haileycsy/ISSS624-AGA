[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "haileycsy",
    "section": "",
    "text": "gif source"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html",
    "title": "Hands-on Ex 01",
    "section": "",
    "text": "Geospatial Data Wrangling"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#different-variations-of-plot",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#different-variations-of-plot",
    "title": "Hands-on Ex 01",
    "section": "Different variations of plot()",
    "text": "Different variations of plot()\n\nsimple plot()geometry onlyspecific attribute\n\n\n\nplot(mpsz)\n\n\n\n\n\n\n\n# Plot only the geometry using st_geometry\n\nplot(st_geometry(mpsz))\n\n\n\n\n\n\n\nplot(mpsz[\"SUBZONE_C\"])"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#assigning-the-right-epsg-code-based-on-coordinate-system",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#assigning-the-right-epsg-code-based-on-coordinate-system",
    "title": "Hands-on Ex 01",
    "section": "Assigning the right EPSG code based on coordinate system",
    "text": "Assigning the right EPSG code based on coordinate system\n\nStep 1: Check EPSG CodeStep 2: st_set_crs()Step 3: Reconfirm EPSG\n\n\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\nThe message indicates that the EPSG is 9001. This is a wrong EPSG code because the correct EPSG code for svy21 should be 3414\n\n\n\nmpsz3414 <- st_set_crs(mpsz, 3414)\n\n\n\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\nEPSG code is now 3414"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#transforming-coordinate-systems",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#transforming-coordinate-systems",
    "title": "Hands-on Ex 01",
    "section": "Transforming Coordinate Systems",
    "text": "Transforming Coordinate Systems\nIn geospatial analytics, it is very common for us to transform the original data from geographic coordinate system to projected coordinate system. This is because geographic coordinate system is not appropriate if the analysis need to use distance or/and area measurements.\n\nStep 1: Check coordinate systemst_transform()Recheck coordinate system\n\n\n\nst_geometry(preschool)\n\nGeometry set for 2290 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6878 ymin: 1.247759 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nPOINT Z (103.8072 1.299333 0)\n\n\nPOINT Z (103.826 1.312839 0)\n\n\nPOINT Z (103.8409 1.348843 0)\n\n\nPOINT Z (103.8048 1.435024 0)\n\n\nPOINT Z (103.839 1.33315 0)\n\n\npreschool dataframe is in wgs84 coordinate system.\n\n\n\npreschool3414 <- st_transform(\n   preschool, \n   crs = 3414)\n\n\n\n\nst_geometry(preschool3414)\n\nGeometry set for 2290 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 11810.03 ymin: 25596.33 xmax: 45404.24 ymax: 49300.88\nz_range:       zmin: 0 zmax: 0\nProjected CRS: SVY21 / Singapore TM\nFirst 5 geometries:\n\n\nPOINT Z (25089.46 31299.16 0)\n\n\nPOINT Z (27189.07 32792.54 0)\n\n\nPOINT Z (28844.56 36773.76 0)\n\n\nPOINT Z (24821.92 46303.16 0)\n\n\nPOINT Z (28637.82 35038.49 0)\n\n\nMessage reveals that the new dataframe has been transformed to svy21 projected coordinate system."
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#using-st_as_sf",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#using-st_as_sf",
    "title": "Hands-on Ex 01",
    "section": "Using st_as_sf()",
    "text": "Using st_as_sf()\n\nlistings_sf <- st_as_sf(\n   listings, \n   coords = c(\"longitude\", \"latitude\"),\n   crs=4326\n  ) %>%\n  st_transform(crs = 3414)\n\n\n\ncoords > provide the column name of the x-coordinates first then followed by the column name of the y-coordinates\ncrs > provide the coordinates system in epsg format. EPSG: 4326 is wgs84 Geographic Coordinate System and EPSG: 3414 is Singapore SVY21 Projected Coordinate System. This can be found at epsg.io"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#checking-for-added-geometry-variable-in-dataframe",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#checking-for-added-geometry-variable-in-dataframe",
    "title": "Hands-on Ex 01",
    "section": "Checking for added geometry variable in dataframe:",
    "text": "Checking for added geometry variable in dataframe:\n\nglimpse(listings_sf)\n\nRows: 3,483\nColumns: 74\n$ id                                           <dbl> 71609, 71896, 71903, 2753…\n$ listing_url                                  <chr> \"https://www.airbnb.com/r…\n$ scrape_id                                    <dbl> 2.023092e+13, 2.023092e+1…\n$ last_scraped                                 <date> 2023-09-23, 2023-09-23, …\n$ source                                       <chr> \"previous scrape\", \"previ…\n$ name                                         <chr> \"Villa in Singapore · ★4.…\n$ description                                  <chr> \"For 3 rooms.Book room 1&…\n$ neighborhood_overview                        <chr> NA, NA, \"Quiet and view o…\n$ picture_url                                  <chr> \"https://a0.muscache.com/…\n$ host_id                                      <dbl> 367042, 367042, 367042, 1…\n$ host_url                                     <chr> \"https://www.airbnb.com/u…\n$ host_name                                    <chr> \"Belinda\", \"Belinda\", \"Be…\n$ host_since                                   <date> 2011-01-29, 2011-01-29, …\n$ host_location                                <chr> \"Singapore\", \"Singapore\",…\n$ host_about                                   <chr> \"Hi My name is Belinda -H…\n$ host_response_time                           <chr> \"within a few hours\", \"wi…\n$ host_response_rate                           <chr> \"100%\", \"100%\", \"100%\", \"…\n$ host_acceptance_rate                         <chr> \"100%\", \"100%\", \"100%\", \"…\n$ host_is_superhost                            <lgl> FALSE, FALSE, FALSE, FALS…\n$ host_thumbnail_url                           <chr> \"https://a0.muscache.com/…\n$ host_picture_url                             <chr> \"https://a0.muscache.com/…\n$ host_neighbourhood                           <chr> \"Tampines\", \"Tampines\", \"…\n$ host_listings_count                          <dbl> 5, 5, 5, 52, 52, 5, 7, 52…\n$ host_total_listings_count                    <dbl> 15, 15, 15, 65, 65, 15, 8…\n$ host_verifications                           <chr> \"['email', 'phone']\", \"['…\n$ host_has_profile_pic                         <lgl> TRUE, TRUE, TRUE, TRUE, T…\n$ host_identity_verified                       <lgl> TRUE, TRUE, TRUE, TRUE, T…\n$ neighbourhood                                <chr> NA, NA, \"Singapore, Singa…\n$ neighbourhood_cleansed                       <chr> \"Tampines\", \"Tampines\", \"…\n$ neighbourhood_group_cleansed                 <chr> \"East Region\", \"East Regi…\n$ property_type                                <chr> \"Private room in villa\", …\n$ room_type                                    <chr> \"Private room\", \"Private …\n$ accommodates                                 <dbl> 3, 1, 2, 1, 1, 4, 2, 1, 1…\n$ bathrooms                                    <lgl> NA, NA, NA, NA, NA, NA, N…\n$ bathrooms_text                               <chr> \"1 private bath\", \"Shared…\n$ bedrooms                                     <dbl> NA, NA, NA, NA, NA, 3, NA…\n$ beds                                         <dbl> 3, 1, 2, 1, 1, 5, 1, 1, 1…\n$ amenities                                    <chr> \"[\\\"Private backyard \\\\u2…\n$ price                                        <chr> \"$150.00\", \"$80.00\", \"$80…\n$ minimum_nights                               <dbl> 92, 92, 92, 60, 60, 92, 9…\n$ maximum_nights                               <dbl> 365, 365, 365, 999, 999, …\n$ minimum_minimum_nights                       <dbl> 92, 92, 92, 60, 60, 92, 9…\n$ maximum_minimum_nights                       <dbl> 92, 92, 92, 60, 60, 92, 9…\n$ minimum_maximum_nights                       <dbl> 1125, 1125, 1125, 1125, 1…\n$ maximum_maximum_nights                       <dbl> 1125, 1125, 1125, 1125, 1…\n$ minimum_nights_avg_ntm                       <dbl> 92, 92, 92, 60, 60, 92, 9…\n$ maximum_nights_avg_ntm                       <dbl> 1125, 1125, 1125, 1125, 1…\n$ calendar_updated                             <lgl> NA, NA, NA, NA, NA, NA, N…\n$ has_availability                             <lgl> TRUE, TRUE, TRUE, TRUE, T…\n$ availability_30                              <dbl> 28, 28, 28, 1, 30, 28, 30…\n$ availability_60                              <dbl> 58, 58, 58, 1, 60, 58, 60…\n$ availability_90                              <dbl> 88, 88, 88, 1, 90, 88, 90…\n$ availability_365                             <dbl> 89, 89, 89, 275, 274, 89,…\n$ calendar_last_scraped                        <date> 2023-09-23, 2023-09-23, …\n$ number_of_reviews                            <dbl> 20, 24, 47, 22, 17, 12, 1…\n$ number_of_reviews_ltm                        <dbl> 0, 0, 0, 0, 3, 0, 0, 1, 3…\n$ number_of_reviews_l30d                       <dbl> 0, 0, 0, 0, 0, 0, 0, 1, 1…\n$ first_review                                 <date> 2011-12-19, 2011-07-30, …\n$ last_review                                  <date> 2020-01-17, 2019-10-13, …\n$ review_scores_rating                         <dbl> 4.44, 4.16, 4.41, 4.40, 4…\n$ review_scores_accuracy                       <dbl> 4.37, 4.22, 4.39, 4.16, 4…\n$ review_scores_cleanliness                    <dbl> 4.00, 4.09, 4.52, 4.26, 4…\n$ review_scores_checkin                        <dbl> 4.63, 4.43, 4.63, 4.47, 4…\n$ review_scores_communication                  <dbl> 4.78, 4.43, 4.64, 4.42, 4…\n$ review_scores_location                       <dbl> 4.26, 4.17, 4.50, 4.53, 4…\n$ review_scores_value                          <dbl> 4.32, 4.04, 4.36, 4.63, 4…\n$ license                                      <chr> NA, NA, NA, \"S0399\", \"S03…\n$ instant_bookable                             <lgl> FALSE, FALSE, FALSE, TRUE…\n$ calculated_host_listings_count               <dbl> 5, 5, 5, 52, 52, 5, 7, 52…\n$ calculated_host_listings_count_entire_homes  <dbl> 0, 0, 0, 1, 1, 0, 1, 1, 1…\n$ calculated_host_listings_count_private_rooms <dbl> 5, 5, 5, 51, 51, 5, 6, 51…\n$ calculated_host_listings_count_shared_rooms  <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ reviews_per_month                            <dbl> 0.14, 0.16, 0.31, 0.17, 0…\n$ geometry                                     <POINT [m]> POINT (41972.5 3639…"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#buffering",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#buffering",
    "title": "Hands-on Ex 01",
    "section": "Buffering",
    "text": "Buffering\nScenario:\nNparks is planning to upgrade the existing cycling paths. To do so, they need to acquire 5 metres of reserved land on both sides of the current cycling path. You are tasked to determine the extent of the land that needs to be acquired and its total area.\n\nDefine buffer zoneCalculate Area NeededSum() total land needed\n\n\nst_buffer() Creates a polygon covering all points of the geometry within a given distance.\n\n#compute the 5-meter buffer zone\n\nbuffer_cycling <- st_buffer(cyclingpath, \n                            # buffer distance\n                            dist = 5, \n                            # number of segments per quadrant\n                            nQuadSegs = 30) \n\n\n\nst_area() returns the area of polygon geometries\n\nbuffer_cycling$AREA <- st_area(buffer_cycling)\n\n\n\n\nsum(buffer_cycling$AREA)\n\n1774367 [m^2]"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#point-in-polygon",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#point-in-polygon",
    "title": "Hands-on Ex 01",
    "section": "Point-in-polygon",
    "text": "Point-in-polygon\nScenario:\nA pre-school service group wants to find out the number of pre-schools in each Planning Subzone.\n\nIdentify and CountSummary StatisticsList the Top Subzones\n\n\n\nmpsz3414$PreSch_count<- lengths(st_intersects(mpsz3414, preschool3414))\n\n\nst_intersects() identifies pre-schools located inside each Planning Subzone by\nlength() of Base R is used to calculate number of pre-schools that fall inside each planning subzone\n\n\n\n\nsummary(mpsz3414$PreSch_count)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    0.00    4.00    7.09   10.00   72.00 \n\n\n\n\n\ntop_n(mpsz3414, 1, PreSch_count)\n\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 39655.33 ymin: 35966 xmax: 42940.57 ymax: 38622.37\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO     SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n1      189          2 TAMPINES EAST    TMSZ02      N   TAMPINES         TM\n     REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR SHAPE_Leng\n1 EAST REGION       ER 21658EAAF84F4D8D 2014-12-05 41122.55 37392.39   10180.62\n  SHAPE_Area                       geometry PreSch_count\n1    4339824 MULTIPOLYGON (((42196.76 38...           72\n\n\n\n\n\n\nWhat is the density of pre-schools by planning subzone?\n\nStep 1: Calculate area of each subzoneStep 2: Compute DensityStep 3: Check Density\n\n\n\nmpsz3414$Area <- mpsz3414 %>%\n  st_area()\n\n\n\nDensity = No. of preschools per subzone area\n\nmpsz3414 <- mpsz3414 %>%\n  mutate(PreSch_density = PreSch_count/Area * 1000000)\n\n\n\n\nsummary(mpsz3414$PreSch_density)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   5.154   6.449  10.908  35.602"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#what-is-the-distribution-of-preschool-density",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#what-is-the-distribution-of-preschool-density",
    "title": "Hands-on Ex 01",
    "section": "What is the distribution of Preschool Density?",
    "text": "What is the distribution of Preschool Density?\n\n\ncode block\nset_urbn_defaults(style = \"print\")\n\nggplot(\n    data = mpsz3414, \n    aes(x = as.numeric(PreSch_density))\n  )+\n  geom_histogram(\n    bins = 20, \n    color = \"#FFFCF9\", \n    fill = \"#1F363D\"\n  ) +\n  labs(\n    title = \"Are pre-schools evenly distributed in Singapore?\",\n    subtitle= \"There are many planning sub-zones with a single pre-school. \\nHowever, there are also 2 planning sub-zones with >20 pre-schools\",\n    x = \"Pre-school density (per km sq)\",\n    y = \"Frequency\"\n  ) +\n  theme(\n    panel.grid.major = element_blank()\n  )\n\n\n\n\n\n\n\ncode block\nggplot(\n    data = mpsz3414, \n    aes(y = PreSch_count, \n        x = as.numeric(PreSch_density))\n  ) +\n  geom_point(\n    size = 2,\n    color = \"#1F363D\",\n    alpha = .6\n  ) +\n  labs(\n    title = \"\",\n    x = \"Pre-school density (per km sq)\",\n    y = \"Pre-school count\"\n  ) +\n  theme(\n    panel.grid.major = element_blank()\n  )\n\n\n\n\n\nCloropleth Mapping"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#how-does-the-data-look-like",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#how-does-the-data-look-like",
    "title": "Hands-on Ex 01",
    "section": "How does the data look like?",
    "text": "How does the data look like?\n\nhead(popdata,10) %>%\n  kbl() %>%\n  kable_styling(\n    full_width = F, \n    bootstrap_options = c(\"condensed\", \"responsive\"))\n\n\n\n \n  \n    PA \n    SZ \n    AG \n    Sex \n    FA \n    Pop \n    Time \n  \n \n\n  \n    Ang Mo Kio \n    Ang Mo Kio Town Centre \n    0_to_4 \n    Males \n    <= 60 \n    0 \n    2011 \n  \n  \n    Ang Mo Kio \n    Ang Mo Kio Town Centre \n    0_to_4 \n    Males \n    >60 to 80 \n    10 \n    2011 \n  \n  \n    Ang Mo Kio \n    Ang Mo Kio Town Centre \n    0_to_4 \n    Males \n    >80 to 100 \n    30 \n    2011 \n  \n  \n    Ang Mo Kio \n    Ang Mo Kio Town Centre \n    0_to_4 \n    Males \n    >100 to 120 \n    80 \n    2011 \n  \n  \n    Ang Mo Kio \n    Ang Mo Kio Town Centre \n    0_to_4 \n    Males \n    >120 \n    20 \n    2011 \n  \n  \n    Ang Mo Kio \n    Ang Mo Kio Town Centre \n    0_to_4 \n    Males \n    Not Available \n    0 \n    2011 \n  \n  \n    Ang Mo Kio \n    Ang Mo Kio Town Centre \n    0_to_4 \n    Females \n    <= 60 \n    0 \n    2011 \n  \n  \n    Ang Mo Kio \n    Ang Mo Kio Town Centre \n    0_to_4 \n    Females \n    >60 to 80 \n    10 \n    2011 \n  \n  \n    Ang Mo Kio \n    Ang Mo Kio Town Centre \n    0_to_4 \n    Females \n    >80 to 100 \n    40 \n    2011 \n  \n  \n    Ang Mo Kio \n    Ang Mo Kio Town Centre \n    0_to_4 \n    Females \n    >100 to 120 \n    90 \n    2011"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#extracting-2020-data-and-creating-pivot-table",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#extracting-2020-data-and-creating-pivot-table",
    "title": "Hands-on Ex 01",
    "section": "Extracting 2020 Data and creating pivot table",
    "text": "Extracting 2020 Data and creating pivot table\n\npopdata2020 <- popdata %>%\n  filter(\n    Time == 2020\n  ) %>%\n  group_by(\n    PA, SZ, AG\n  ) %>%\n  summarise(\n    POP = sum(Pop)\n  ) %>%\n  ungroup() %>%\n  pivot_wider(\n    names_from = AG, \n    values_from = POP\n  ) %>%\n  mutate(\n    `YOUNG` = rowSums(.[3:6]) + rowSums(.[12]),\n    `ECONOMICALLY ACTIVE` = rowSums(.[7:11]) + rowSums(.[13:15]),\n    `AGED`= rowSums(.[16:21]),\n    `TOTAL`= rowSums(.[3:21])\n  ) %>%  \n  # Define dependency ratio\n  mutate(`DEPENDENCY` = (`YOUNG` + `AGED`)/`ECONOMICALLY ACTIVE`\n  ) %>%\n  # Convert PA and SZ fields to upper case\n  mutate_at(.vars = vars(PA, SZ), \n            .funs = funs(toupper)\n  ) %>%\n  select(\n    `PA`, `SZ`, `YOUNG`,`ECONOMICALLY ACTIVE`, `AGED`,`TOTAL`, `DEPENDENCY`\n  ) %>%\n  # Get data for only economically active subzones\n  filter(`ECONOMICALLY ACTIVE` > 0)\n\n\nhead(popdata2020,10) %>%\n  kbl() %>%\n  kable_styling(\n    full_width = F, \n    bootstrap_options = c(\"condensed\", \"responsive\"))\n\n\n\n \n  \n    PA \n    SZ \n    YOUNG \n    ECONOMICALLY ACTIVE \n    AGED \n    TOTAL \n    DEPENDENCY \n  \n \n\n  \n    ANG MO KIO \n    ANG MO KIO TOWN CENTRE \n    1440 \n    2640 \n    770 \n    4850 \n    0.8371212 \n  \n  \n    ANG MO KIO \n    CHENG SAN \n    6660 \n    15380 \n    6080 \n    28120 \n    0.8283485 \n  \n  \n    ANG MO KIO \n    CHONG BOON \n    6150 \n    13970 \n    6450 \n    26570 \n    0.9019327 \n  \n  \n    ANG MO KIO \n    KEBUN BAHRU \n    5500 \n    12040 \n    5080 \n    22620 \n    0.8787375 \n  \n  \n    ANG MO KIO \n    SEMBAWANG HILLS \n    2130 \n    3390 \n    1270 \n    6790 \n    1.0029499 \n  \n  \n    ANG MO KIO \n    SHANGRI-LA \n    3970 \n    8430 \n    3540 \n    15940 \n    0.8908660 \n  \n  \n    ANG MO KIO \n    TAGORE \n    2220 \n    4160 \n    1520 \n    7900 \n    0.8990385 \n  \n  \n    ANG MO KIO \n    TOWNSVILLE \n    4720 \n    11430 \n    5050 \n    21200 \n    0.8547682 \n  \n  \n    ANG MO KIO \n    YIO CHU KANG EAST \n    1190 \n    2230 \n    740 \n    4160 \n    0.8654709 \n  \n  \n    ANG MO KIO \n    YIO CHU KANG WEST \n    6610 \n    12810 \n    4680 \n    24100 \n    0.8813427"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#joining-attributes-to-geospatial-data",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#joining-attributes-to-geospatial-data",
    "title": "Hands-on Ex 01",
    "section": "Joining Attributes to Geospatial data",
    "text": "Joining Attributes to Geospatial data\n\nmpsz_pop2020 <- left_join(\n                  mpsz, popdata2020,\n                  by = c(\"SUBZONE_N\" = \"SZ\"))\n\n# Create rds file in new data folder\nwrite_rds(mpsz_pop2020, \"data/rds/mpszpop2020.rds\")"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#simple-map-using-qtm",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#simple-map-using-qtm",
    "title": "Hands-on Ex 01",
    "section": "Simple map using qtm()",
    "text": "Simple map using qtm()\n\ntmap_mode(\"plot\")\nqtm(mpsz_pop2020, \n    fill = \"DEPENDENCY\")"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#using-tmap-arguments",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#using-tmap-arguments",
    "title": "Hands-on Ex 01",
    "section": "Using tmap arguments",
    "text": "Using tmap arguments\n\n\ncode block\ntm_shape(mpsz_pop2020\n  ) +\n  tm_fill(\n    \"DEPENDENCY\", \n    style = \"quantile\", \n    palette = \"Purples\",\n    title = \"Dependency ratio\"\n  ) +\n  tm_layout(\n    main.title = \"Distribution of Dependency Ratio by planning subzone\",\n    main.title.position = \"center\",\n    main.title.size = 1.2,\n    legend.height = .25, \n    legend.width = .35,\n    frame = FALSE\n  ) +\n  tm_borders(\n    alpha = .3\n  ) +\n  tm_compass(\n    type=\"8star\", \n    size = 2\n  ) +\n  tm_scale_bar() +\n  tm_grid(\n    alpha = .1\n  ) +\n  tm_credits(\n    \"Source: Planning Sub-zone boundary from Urban Redevelopment Authority (URA)\\n and Population data from Department of Statistics DOS\", \n    position = c(\"left\", \"bottom\")\n  )"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#building-a-tmap",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#building-a-tmap",
    "title": "Hands-on Ex 01",
    "section": "Building a tmap",
    "text": "Building a tmap\n\nbasic mapUpgrade to CloroplethUsing tm_fill() and tm_border()\n\n\ntm_shape() is used to define the input data (i.e mpsz_pop2020) and tm_polygons() is used to draw the planning subzone polygons\n\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n\n\n\n\n\n\nAssign variable to tm_polygons() to visualise geographical distribution\n\ntm_shape(mpsz_pop2020) +\n  tm_polygons(\"DEPENDENCY\")\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\")\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\") +\n  tm_borders(\n    # Border linewidth\n    lwd = .2,  \n    # Border color\n    col = \"#1F363D\",\n    # transparency of color\n    alpha = .8\n  )"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#data-classification-methods",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#data-classification-methods",
    "title": "Hands-on Ex 01",
    "section": "Data Classification Methods",
    "text": "Data Classification Methods\n\ntmap provides a total 10 data classification methods: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks\n\n\njenksequalkmeansfisherCustom Breaks\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          palette = \"Purples\",\n          n = 5,\n          style = \"jenks\"\n  ) +\n  tm_borders(alpha = .5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          palette = \"Greens\",\n          n = 5,\n          style = \"equal\"\n  ) +\n  tm_borders(alpha = .5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          palette = \"Blues\",\n          n = 5,\n          style = \"kmeans\"\n  ) +\n  tm_borders(alpha = .5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          palette = \"Reds\",\n          n = 5,\n          style = \"fisher\"\n  ) +\n  tm_borders(alpha = .5)\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00),\n          palette = \"-Purples\"\n  ) +\n  tm_borders(alpha = .5)"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#legends-and-styles",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#legends-and-styles",
    "title": "Hands-on Ex 01",
    "section": "Legends and Styles",
    "text": "Legends and Styles\n\ntm_shape(mpsz_pop2020\n  )+\n  tm_fill(\"DEPENDENCY\", \n          style = \"jenks\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = .1\n  ) +\n  tm_layout(\n    main.title = \"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\",\n            main.title.position = \"center\",\n            main.title.size = .7,\n            legend.height = .25, \n            legend.width = .25,\n            legend.outside = FALSE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE\n  ) +\n  tm_borders(\n    alpha = .5\n  ) +\n  tm_style(\"natural\")\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"No. of persons\"\n  ) +\n  tm_layout(main.title = \"Distribution of Dependency Ratio \\nby planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE\n  ) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\")\n  ) +\n  tm_style(\"classic\")"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#facet-maps",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#facet-maps",
    "title": "Hands-on Ex 01",
    "section": "Facet maps",
    "text": "Facet maps\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\n    c(\"YOUNG\", \"AGED\"),\n    style = \"equal\", \n    palette = \"Reds\"\n  ) +\n  tm_layout(\n    legend.position = c(\"right\", \"bottom\")\n  ) +\n  tm_borders(\n    alpha = 0.5\n  ) +\n  tmap_style(\"albatross\")\n\n\n\n\n\ntm_shape(mpsz_pop2020\n  )+ \n  tm_polygons(\n    c(\"DEPENDENCY\",\"AGED\"),\n    style = c(\"equal\", \"quantile\"), \n    palette = list(\"Blues\",\"Greens\")\n  ) +\n  tm_layout(legend.position = c(\"right\", \"bottom\")\n  ) +\n  tmap_style(\"cobalt\")\n\n\n\n\n\ntm_shape(mpsz_pop2020\n  ) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Purples\",\n          thres.poly = 0\n  ) + \n  tm_facets(by=\"REGION_N\", \n            free.coords = TRUE, \n            drop.shapes = TRUE\n  ) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 16\n  ) +\n  tm_borders(alpha = .2\n  ) +\n  tm_style(\"classic\")"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#stand-alone-maps-with-tmap_arrange",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#stand-alone-maps-with-tmap_arrange",
    "title": "Hands-on Ex 01",
    "section": "stand-alone maps with tmap_arrange()",
    "text": "stand-alone maps with tmap_arrange()\n\nyoungmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\n    \"YOUNG\", \n    style = \"quantile\", \n    palette = \"Reds\"\n  ) +\n  tm_style(\"white\")\n\nagedmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\n    \"AGED\", \n    style = \"quantile\", \n    palette = \"Blues\"\n  ) +\n  tm_style(\"white\")\n\ntmap_arrange(youngmap, agedmap, \n             asp = 1, \n             ncol = 2)"
  },
  {
    "objectID": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#mapping-only-specific-criteria",
    "href": "Hands-on_Ex/hoe1/Hands-on_Ex01.html#mapping-only-specific-criteria",
    "title": "Hands-on Ex 01",
    "section": "Mapping only specific criteria",
    "text": "Mapping only specific criteria\n\ntm_shape(\n  # Only map central region\n  mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\", ]\n  )+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Greens\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1\n  ) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE\n  ) +\n  tm_borders(alpha = .5)"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html",
    "title": "Hands-on Ex 2",
    "section": "",
    "text": "Spatial Weights and Applications\nA key aspect of spatial analysis is to measure the strength of the spatial relationships between spatial objects, or how these related spatial objects influence each other. This would allow us to further the analysis by computing spatial autocorrelation indices, implementing spatial econometrics techniques, studying the spatial distribution of observations, as well as performing spatial sampling or graph partitioning. Source: Handbook of Spatial Analysis\nComputing spatial weights and neighbor links is a necessary part of this analysis process, and is the key focus of this exercise.\n\nWhat are Spatial Weights?\nSpatial weights are one way to represent graphs in geographic data science and spatial statistics and are widely used to represent geographic relationships between the observational units in a spatial dataset.\n\nSpatial weights often express our knowledge about spatial relationships. For example, proximity and adjacency are common spatial questions: What neighborhoods are you surrounded by? How many gas stations are within 5 miles of my stalled car?\nSpatial questions target specific information about the spatial configuration of a specific target (“a neighborhood,” “my stalled car”) and geographically connected relevant sites (“adjacent neighborhoods”, “nearby gas stations”)"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#loading-the-data",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#loading-the-data",
    "title": "Hands-on Ex 2",
    "section": "3.1 Loading the data",
    "text": "3.1 Loading the data\n\nGeospatial shapefileAspatial csvJoining the datasets\n\n\n\n\ncode block\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n\n\nReading layer `Hunan' from data source \n  `C:\\haileycsy\\ISSS624-AGA\\Hands-on_Ex\\hoe2\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\n\n\n\ncode block\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n\n\n\n\nBy performing a left_join(), the geospatial dataframe hunan will be updated with attribute fields of hunan2012\n\n\ncode block\nhunan <- left_join(hunan, hunan2012) %>%\n  select(1:4, 7, 15)\n\n\n\n\n\n\n\ncode block\nhead(hunan,10) %>%\n  kbl() %>%\n  kable_styling(\n    full_width = F, \n    bootstrap_options = c(\"condensed\", \"responsive\"))\n\n\n\n\n \n  \n    NAME_2 \n    ID_3 \n    NAME_3 \n    ENGTYPE_3 \n    County \n    GDPPC \n    geometry \n  \n \n\n  \n    Changde \n    21098 \n    Anxiang \n    County \n    Anxiang \n    23667 \n    POLYGON ((112.0625 29.75523... \n  \n  \n    Changde \n    21100 \n    Hanshou \n    County \n    Hanshou \n    20981 \n    POLYGON ((112.2288 29.11684... \n  \n  \n    Changde \n    21101 \n    Jinshi \n    County City \n    Jinshi \n    34592 \n    POLYGON ((111.8927 29.6013,... \n  \n  \n    Changde \n    21102 \n    Li \n    County \n    Li \n    24473 \n    POLYGON ((111.3731 29.94649... \n  \n  \n    Changde \n    21103 \n    Linli \n    County \n    Linli \n    25554 \n    POLYGON ((111.6324 29.76288... \n  \n  \n    Changde \n    21104 \n    Shimen \n    County \n    Shimen \n    27137 \n    POLYGON ((110.8825 30.11675... \n  \n  \n    Changsha \n    21109 \n    Liuyang \n    County City \n    Liuyang \n    63118 \n    POLYGON ((113.9905 28.5682,... \n  \n  \n    Changsha \n    21110 \n    Ningxiang \n    County \n    Ningxiang \n    62202 \n    POLYGON ((112.7181 28.38299... \n  \n  \n    Changsha \n    21111 \n    Wangcheng \n    County \n    Wangcheng \n    70666 \n    POLYGON ((112.7914 28.52688... \n  \n  \n    Chenzhou \n    21112 \n    Anren \n    County \n    Anren \n    12761 \n    POLYGON ((113.1757 26.82734..."
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#computing-queen-contiguity-based-neighbours",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#computing-queen-contiguity-based-neighbours",
    "title": "Hands-on Ex 2",
    "section": "6.1 Computing Queen contiguity based neighbours",
    "text": "6.1 Computing Queen contiguity based neighbours\nThe code chunk below computes a contiguity matrix based on Queen contiguity principle and returns a neighbor list object:\n\nwm_q <- poly2nb(hunan, \n                queen = TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\n\nThe summary report shows that:\n\nThere are 88 area units in Hunan\nThe most connected area unit has 11 neighbors (links)\nThe two least connected areas have only 1 neighbor\n\n\n\nListing specific neighborsRetrieving Country names by polygon #Retrieving GDPCC of countries by polygon #\n\n\nFor each polygon in our polygon object, wm_q lists all neighboring polygons. For example, to see the neighbors for polygon #1 in the object:\n\nwm_q[[1]]\n\n[1]  2  3  4 57 85\n\n\nPolygon #1 has 5 neighbors.\n\n\nWe can retrieve the county name of Polygon ID=1 by using the code chunk below:\n\nhunan$County[1]\n\n[1] \"Anxiang\"\n\n\nTo reveal the county names of the five neighboring polygons, the code chunk will be used:\n\nhunan$NAME_3[c(2,3,4,57,85)]\n\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n\n\n\n\n\n# Store all neighbor polygon IDs in new variable\nnb1 <- wm_q[[1]]\n# Replace polygon IDs in the variable with respective GDPPC\nnb1 <- hunan$GDPPC[nb1]\n\nnb1\n\n[1] 20981 34592 24473 21311 22879\n\n\nThe printed output above shows that the GDPPC of the five nearest neighbors based on Queen’s method are 20981, 34592, 24473, 21311 and 22879 respectively.\n\n6.1.1 Displaying complete matrix\nYou can display the complete weight matrix by using str()\n\nstr(wm_q)\n\nList of 88\n $ : int [1:5] 2 3 4 57 85\n $ : int [1:5] 1 57 58 78 85\n $ : int [1:4] 1 4 5 85\n $ : int [1:4] 1 3 5 6\n $ : int [1:4] 3 4 6 85\n $ : int [1:5] 4 5 69 75 85\n $ : int [1:4] 67 71 74 84\n $ : int [1:7] 9 46 47 56 78 80 86\n $ : int [1:6] 8 66 68 78 84 86\n $ : int [1:8] 16 17 19 20 22 70 72 73\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:3] 11 15 17\n $ : int [1:4] 13 14 17 83\n $ : int [1:5] 10 17 22 72 83\n $ : int [1:7] 10 11 14 15 16 72 83\n $ : int [1:5] 20 22 23 77 83\n $ : int [1:6] 10 20 21 73 74 86\n $ : int [1:7] 10 18 19 21 22 23 82\n $ : int [1:5] 19 20 35 82 86\n $ : int [1:5] 10 16 18 20 83\n $ : int [1:7] 18 20 38 41 77 79 82\n $ : int [1:5] 25 28 31 32 54\n $ : int [1:5] 24 28 31 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:3] 26 29 42\n $ : int [1:5] 24 25 33 49 54\n $ : int [1:3] 27 37 42\n $ : int 33\n $ : int [1:8] 24 25 32 36 39 40 56 81\n $ : int [1:8] 24 31 50 54 55 56 75 85\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 47 80 82 86\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:4] 29 42 43 44\n $ : int [1:4] 23 44 77 79\n $ : int [1:5] 31 40 42 43 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:7] 26 27 29 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:4] 37 38 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:3] 8 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:5] 32 48 52 54 55\n $ : int [1:3] 48 49 52\n $ : int [1:5] 48 49 50 51 54\n $ : int [1:3] 48 55 75\n $ : int [1:6] 24 28 32 49 50 52\n $ : int [1:5] 32 48 50 53 75\n $ : int [1:7] 8 31 32 36 78 80 85\n $ : int [1:6] 1 2 58 64 76 85\n $ : int [1:5] 2 57 68 76 78\n $ : int [1:4] 60 61 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:7] 12 59 60 62 63 77 87\n $ : int [1:3] 61 77 87\n $ : int [1:4] 12 61 77 83\n $ : int [1:2] 57 76\n $ : int 76\n $ : int [1:5] 9 67 68 76 84\n $ : int [1:4] 7 66 76 84\n $ : int [1:5] 9 58 66 76 78\n $ : int [1:3] 6 75 85\n $ : int [1:3] 10 72 73\n $ : int [1:3] 7 73 74\n $ : int [1:5] 10 11 16 17 70\n $ : int [1:5] 10 19 70 71 74\n $ : int [1:6] 7 19 71 73 84 86\n $ : int [1:6] 6 32 53 55 69 85\n $ : int [1:7] 57 58 64 65 66 67 68\n $ : int [1:7] 18 23 38 61 62 63 83\n $ : int [1:7] 2 8 9 56 58 68 85\n $ : int [1:7] 23 38 40 41 43 44 45\n $ : int [1:8] 8 34 35 36 41 45 47 56\n $ : int [1:6] 25 26 31 33 39 42\n $ : int [1:5] 20 21 23 35 41\n $ : int [1:9] 12 13 15 16 17 18 22 63 77\n $ : int [1:6] 7 9 66 67 74 86\n $ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n $ : int [1:9] 8 9 19 21 35 46 47 74 84\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n - attr(*, \"type\")= chr \"queen\"\n - attr(*, \"sym\")= logi TRUE"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#creating-rook-contiguity-based-neighbours",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#creating-rook-contiguity-based-neighbours",
    "title": "Hands-on Ex 2",
    "section": "6.2 Creating Rook contiguity based neighbours",
    "text": "6.2 Creating Rook contiguity based neighbours\nCompute the Rook contiguity matrix by altering queen argument of poly2nb() function to return a neighbor list object:\n\nwm_r <- poly2nb(hunan, \n                queen = FALSE)\nsummary(wm_r)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n\n\n\nThe summary report shows that:\n\nThere are 88 area units in Hunan\nThe most connected area unit has 10 neighbors (links)\nThe two least connected areas have only 1 neighbor"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#plotting-queen-contiguity-as-a-map",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#plotting-queen-contiguity-as-a-map",
    "title": "Hands-on Ex 2",
    "section": "7.1 Plotting Queen contiguity as a map",
    "text": "7.1 Plotting Queen contiguity as a map\n\n\ncode block\nplot(hunan$geometry, \n     border = \"#ABA9C3\")\nplot(wm_q, \n     coords, \n     pch = 20, \n     cex = .7, \n     add = TRUE, \n     col= \"salmon\"\n     )"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#plotting-rook-contiguity-as-a-map",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#plotting-rook-contiguity-as-a-map",
    "title": "Hands-on Ex 2",
    "section": "7.2 Plotting Rook contiguity as a map",
    "text": "7.2 Plotting Rook contiguity as a map\n\n\ncode block\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_r, \n     coords, \n     pch = 19, \n     cex = 0.6, \n     add = TRUE, \n     col = \"#129490\")"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#putting-both-maps-together",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#putting-both-maps-together",
    "title": "Hands-on Ex 2",
    "section": "7.3 Putting both maps together",
    "text": "7.3 Putting both maps together\n\n\ncode block\npar(mfrow = c(1,2))\n\n# Queen\nplot(hunan$geometry, \n     border = \"lightgrey\")\nplot(wm_q, \n     coords, \n     pch = 20, \n     cex = .7, \n     add = TRUE, \n     col = \"salmon\",\n     main = \"Queen Contiguity\"\n     )\n\n# Rook\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_r, \n     coords, \n     pch = 19, \n     cex = 0.6, \n     add = TRUE, \n     col = \"#129490\",\n     main = \"Rook Contiguity\")"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#defining-cut-off-distance",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#defining-cut-off-distance",
    "title": "Hands-on Ex 2",
    "section": "8.1 Defining cut-off distance",
    "text": "8.1 Defining cut-off distance\n\nStep 1: Create a list of neighborsStep 2: Calculate distance using nbdists()Step 3: Determine upper threshold\n\n\n\nknearneigh(coords) is used to find k nearest neighbors for each point in the spatial dataset defined by the coords variable. Returns: k-nearest neighbor object (kn object)\nknn2nb() is then used to convert the k-nearest neighbor object (kn object) into a neighbors list (nb object). This nb object represents the spatial relationships between neighboring regions based on the k-nearest neighbors and returns a neighbor list object:\n\n\nk1 <- knn2nb(knearneigh(coords))\nk1\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 88 \nPercentage nonzero weights: 1.136364 \nAverage number of links: 1 \nNon-symmetric neighbours list\n\n\n\n\n\nnbdists() calculates the distances between neighboring regions defined by the neighbors list k1\nThe longlat = TRUE argument indicates that the distances should be calculated assuming longitude and latitude coordinates, and it returns the distances in kilometers\nunlist() flattens the result, converting it from a list structure to a simple numeric vector\n\n\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\n\n\n\n\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\nThe summary report shows that the largest first nearest neighbour distance is 61.79 km, so using this as the upper threshold gives certainty that all units will have at least one neighbour."
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#computing-fixed-distance-weight-matrix",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#computing-fixed-distance-weight-matrix",
    "title": "Hands-on Ex 2",
    "section": "8.2 Computing fixed distance weight matrix",
    "text": "8.2 Computing fixed distance weight matrix\nThis is done using dnearneigh():\n\nwm_d62 <- dnearneigh(\n  coords, \n  # specify lower and upper distance bands\n  0, 62, \n  longlat = TRUE)\n\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\n\nThe summary report shows that:\n\nThere are 88 area units in Hunan\nThere are 324 links between regions that fall within the distance band of 0 - 62km\nOn average, each region has about 3-4 neighbors that fall within the distance band\n\n\n\nContent of wm_d62 weight matrixStructure of wm_d62 weight matrix\n\n\n\nstr(wm_d62)\n\nList of 88\n $ : int [1:5] 3 4 5 57 64\n $ : int [1:4] 57 58 78 85\n $ : int [1:4] 1 4 5 57\n $ : int [1:3] 1 3 5\n $ : int [1:4] 1 3 4 85\n $ : int 69\n $ : int [1:2] 67 84\n $ : int [1:4] 9 46 47 78\n $ : int [1:4] 8 46 68 84\n $ : int [1:4] 16 22 70 72\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:2] 11 17\n $ : int 13\n $ : int [1:4] 10 17 22 83\n $ : int [1:3] 11 14 16\n $ : int [1:3] 20 22 63\n $ : int [1:5] 20 21 73 74 82\n $ : int [1:5] 18 19 21 22 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:4] 10 16 18 20\n $ : int [1:3] 41 77 82\n $ : int [1:4] 25 28 31 54\n $ : int [1:4] 24 28 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:2] 26 29\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:2] 27 37\n $ : int 33\n $ : int [1:2] 24 36\n $ : int 50\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:5] 31 34 45 56 80\n $ : int [1:2] 29 42\n $ : int [1:3] 44 77 79\n $ : int [1:4] 40 42 43 81\n $ : int [1:3] 39 45 79\n $ : int [1:5] 23 35 45 79 82\n $ : int [1:5] 26 37 39 43 81\n $ : int [1:3] 39 42 44\n $ : int [1:2] 38 43\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:5] 8 9 35 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:4] 48 49 50 52\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:2] 48 55\n $ : int [1:5] 24 28 49 50 52\n $ : int [1:4] 48 50 53 75\n $ : int 36\n $ : int [1:5] 1 2 3 58 64\n $ : int [1:5] 2 57 64 66 68\n $ : int [1:3] 60 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:5] 12 60 62 63 87\n $ : int [1:4] 61 63 77 87\n $ : int [1:5] 12 18 61 62 83\n $ : int [1:4] 1 57 58 76\n $ : int 76\n $ : int [1:5] 58 67 68 76 84\n $ : int [1:2] 7 66\n $ : int [1:4] 9 58 66 84\n $ : int [1:2] 6 75\n $ : int [1:3] 10 72 73\n $ : int [1:2] 73 74\n $ : int [1:3] 10 11 70\n $ : int [1:4] 19 70 71 74\n $ : int [1:5] 19 21 71 73 86\n $ : int [1:2] 55 69\n $ : int [1:3] 64 65 66\n $ : int [1:3] 23 38 62\n $ : int [1:2] 2 8\n $ : int [1:4] 38 40 41 45\n $ : int [1:5] 34 35 36 45 47\n $ : int [1:5] 25 26 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:4] 12 13 16 63\n $ : int [1:4] 7 9 66 68\n $ : int [1:2] 2 5\n $ : int [1:4] 21 46 47 74\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 62, longlat = TRUE)\n - attr(*, \"dnn\")= num [1:2] 0 62\n - attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n - attr(*, \"nbtype\")= chr \"distance\"\n - attr(*, \"sym\")= logi TRUE\n\n\n\n\nUse a combination oftable() and card() to return a contingency matrix of number of neighbors per country:\n\ntable(hunan$County, \n    # list number of neighbors for each area\n      card(wm_d62))\n\n               \n                1 2 3 4 5 6\n  Anhua         1 0 0 0 0 0\n  Anren         0 0 0 1 0 0\n  Anxiang       0 0 0 0 1 0\n  Baojing       0 0 0 0 1 0\n  Chaling       0 0 1 0 0 0\n  Changning     0 0 1 0 0 0\n  Changsha      0 0 0 1 0 0\n  Chengbu       0 1 0 0 0 0\n  Chenxi        0 0 0 1 0 0\n  Cili          0 1 0 0 0 0\n  Dao           0 0 0 1 0 0\n  Dongan        0 0 1 0 0 0\n  Dongkou       0 0 0 1 0 0\n  Fenghuang     0 0 0 1 0 0\n  Guidong       0 0 1 0 0 0\n  Guiyang       0 0 0 1 0 0\n  Guzhang       0 0 0 0 0 1\n  Hanshou       0 0 0 1 0 0\n  Hengdong      0 0 0 0 1 0\n  Hengnan       0 0 0 0 1 0\n  Hengshan      0 0 0 0 0 1\n  Hengyang      0 0 0 0 0 1\n  Hongjiang     0 0 0 0 1 0\n  Huarong       0 0 0 1 0 0\n  Huayuan       0 0 0 1 0 0\n  Huitong       0 0 0 1 0 0\n  Jiahe         0 0 0 0 1 0\n  Jianghua      0 0 1 0 0 0\n  Jiangyong     0 1 0 0 0 0\n  Jingzhou      0 1 0 0 0 0\n  Jinshi        0 0 0 1 0 0\n  Jishou        0 0 0 0 0 1\n  Lanshan       0 0 0 1 0 0\n  Leiyang       0 0 0 1 0 0\n  Lengshuijiang 0 0 1 0 0 0\n  Li            0 0 1 0 0 0\n  Lianyuan      0 0 0 0 1 0\n  Liling        0 1 0 0 0 0\n  Linli         0 0 0 1 0 0\n  Linwu         0 0 0 1 0 0\n  Linxiang      1 0 0 0 0 0\n  Liuyang       0 1 0 0 0 0\n  Longhui       0 0 1 0 0 0\n  Longshan      0 1 0 0 0 0\n  Luxi          0 0 0 0 1 0\n  Mayang        0 0 0 0 0 1\n  Miluo         0 0 0 0 1 0\n  Nan           0 0 0 0 1 0\n  Ningxiang     0 0 0 1 0 0\n  Ningyuan      0 0 0 0 1 0\n  Pingjiang     0 1 0 0 0 0\n  Qidong        0 0 1 0 0 0\n  Qiyang        0 0 1 0 0 0\n  Rucheng       0 1 0 0 0 0\n  Sangzhi       0 1 0 0 0 0\n  Shaodong      0 0 0 0 1 0\n  Shaoshan      0 0 0 0 1 0\n  Shaoyang      0 0 0 1 0 0\n  Shimen        1 0 0 0 0 0\n  Shuangfeng    0 0 0 0 0 1\n  Shuangpai     0 0 0 1 0 0\n  Suining       0 0 0 0 1 0\n  Taojiang      0 1 0 0 0 0\n  Taoyuan       0 1 0 0 0 0\n  Tongdao       0 1 0 0 0 0\n  Wangcheng     0 0 0 1 0 0\n  Wugang        0 0 1 0 0 0\n  Xiangtan      0 0 0 1 0 0\n  Xiangxiang    0 0 0 0 1 0\n  Xiangyin      0 0 0 1 0 0\n  Xinhua        0 0 0 0 1 0\n  Xinhuang      1 0 0 0 0 0\n  Xinning       0 1 0 0 0 0\n  Xinshao       0 0 0 0 0 1\n  Xintian       0 0 0 0 1 0\n  Xupu          0 1 0 0 0 0\n  Yanling       0 0 1 0 0 0\n  Yizhang       1 0 0 0 0 0\n  Yongshun      0 0 0 1 0 0\n  Yongxing      0 0 0 1 0 0\n  You           0 0 0 1 0 0\n  Yuanjiang     0 0 0 0 1 0\n  Yuanling      1 0 0 0 0 0\n  Yueyang       0 0 1 0 0 0\n  Zhijiang      0 0 0 0 1 0\n  Zhongfang     0 0 0 1 0 0\n  Zhuzhou       0 0 0 0 1 0\n  Zixing        0 0 1 0 0 0"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#row-standardization",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#row-standardization",
    "title": "Hands-on Ex 2",
    "section": "12.1 Row Standardization",
    "text": "12.1 Row Standardization\nRow-standardization involves dividing each weight in a row by the sum of weights in that row. This ensures that the weights for each observation (row) in the matrix sum to 1, making it a row-standardized spatial weight matrix.\nRow-standardization helps to remove the influence of the number of neighbors each observation has, making the spatial weight matrix more comparable across different datasets or regions.\nnb2listw() function converts a neighbors list object into a weight list object:\n\nrswm_q <- nb2listw(wm_q, \n            # Specify spatial weights matrix\n                   style = \"W\", \n            # regions with no neighbors are retained in matrix, weights set to zero\n                   zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\n\n\ncode block\nsummary(unlist(rswm_q$weights))\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n0.09091 0.14286 0.20000 0.19643 0.20000 1.00000"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#unstandardized-weight-matrix",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#unstandardized-weight-matrix",
    "title": "Hands-on Ex 2",
    "section": "12.2 Unstandardized weight matrix",
    "text": "12.2 Unstandardized weight matrix\nstyle = “B” Creates a binary (unstandardized) weight list object:\n\n\ncode block\nrswm_ids <- nb2listw(wm_q, glist = ids, style = \"B\", zero.policy = TRUE)\nrswm_ids\n\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn       S0        S1     S2\nB 88 7744 8.786867 0.3776535 3.8137\n\n\n\n\ncode block\nsummary(unlist(rswm_ids$weights))\n\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n0.008218 0.015088 0.018739 0.019614 0.022823 0.040338"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#spatial-lag-with-row-standardized-weights",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#spatial-lag-with-row-standardized-weights",
    "title": "Hands-on Ex 2",
    "section": "13.1 Spatial lag with row-standardized weights",
    "text": "13.1 Spatial lag with row-standardized weights\n\nCalculate variable spatial lag valueAppend values to main dataframe\n\n\nThe following code calculates the GDPPC Lag value, or average neighbor GDPPC value for each polygon and returns it as a numeric vector:\n\nGDPPC_lag <- lag.listw(rswm_q, hunan$GDPPC)\nGDPPC_lag \n\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n\n\n\n\n\n# create a list of Hunan provinces and corresponding spatial lag GDPPC values\nlag_list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))\n\n# Transform list into dataframe\nlag_res <- as.data.frame(lag_list)\n\n# Assign column names to dataframe\ncolnames(lag_res) <- c(\"NAME_3\", \"lag GDPPC\")\n\n# Join to main hunan dataframe\nhunan <- left_join(hunan,lag_res)\n\nhead(hunan)\n\nSimple feature collection with 6 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 110.4922 ymin: 28.61762 xmax: 112.3013 ymax: 30.12812\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3  County GDPPC lag GDPPC\n1 Changde 21098 Anxiang      County Anxiang 23667  24847.20\n2 Changde 21100 Hanshou      County Hanshou 20981  22724.80\n3 Changde 21101  Jinshi County City  Jinshi 34592  24143.25\n4 Changde 21102      Li      County      Li 24473  27737.50\n5 Changde 21103   Linli      County   Linli 25554  27270.25\n6 Changde 21104  Shimen      County  Shimen 27137  21248.80\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n4 POLYGON ((111.3731 29.94649...\n5 POLYGON ((111.6324 29.76288...\n6 POLYGON ((110.8825 30.11675...\n\n\nThis reveals that lag GDPPC is stored as a new column in the hunan dataframe.\n\n\n\nComparing GDPPC and Spatial Lag GDPPC\n\n\ncode block\n# Plot normal GDPPC cloropleth map\ngdppc <- qtm(hunan, \"GDPPC\")\n\n# Plot lag GDPPC cloropleth map\nlag_gdppc <- qtm(hunan, \"lag GDPPC\")\n\n# Arrange in 2 columns\ntmap_arrange(gdppc, lag_gdppc, asp = 1, ncol = 2)"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#spatial-lag-as-a-sum-of-neighboring-values",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#spatial-lag-as-a-sum-of-neighboring-values",
    "title": "Hands-on Ex 2",
    "section": "13.2 Spatial lag as a sum of neighboring values",
    "text": "13.2 Spatial lag as a sum of neighboring values\nAnother way to calculate spatial lag is to sum neighboring values by assigning binary weights."
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#create-binary-spatial-weights-matrix",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#create-binary-spatial-weights-matrix",
    "title": "Hands-on Ex 2",
    "section": "13.3 Create binary spatial weights matrix",
    "text": "13.3 Create binary spatial weights matrix\n\n\ncode block\n# For every neighbor an area has, assign value '1'\nb_weights <- lapply(wm_q, function(x) 0*x +1)\n\n# Create binary spatial weight matrix\nb_weights2 <- nb2listw(wm_q, \n                       glist = b_weights, \n                       style = \"B\")\n\nb_weights2\n\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#compute-lag-gdppc",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#compute-lag-gdppc",
    "title": "Hands-on Ex 2",
    "section": "13.4 Compute Lag GDPPC",
    "text": "13.4 Compute Lag GDPPC\n\n# create a list of Hunan provinces and corresponding spatial lag GDPPC values\nlag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\n\n# Transform list object into dataframe\nlag_res <- as.data.frame(lag_sum)\n\n# assign column names\ncolnames(lag_res) <- c(\"NAME_3\", \"lag_sum GDPPC\")\n\n# Append to hunan dataframe\n\nhunan <- left_join(hunan, lag_res)\n\nComparing GDPPC and Spatial Lag GDPPC\n\n\ncode block\n# original GDPPC Plot\ngdppc <- qtm(hunan, \"GDPPC\")\n\n# Lag sum GDPPC plot\nlag_sum_gdppc <- qtm(hunan, \"lag_sum GDPPC\")\n\n# Arrange side by side\ntmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#spatial-window-average",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#spatial-window-average",
    "title": "Hands-on Ex 2",
    "section": "13.5 Spatial window average",
    "text": "13.5 Spatial window average\nThe spatial window average uses row-standardized weights and includes the diagonal element. To do this in R, we need to go back to the neighbors structure and add the diagonal element before assigning weights.\n\nincluding selfCreate Spatial weights ListCalculate spatial lag variable from new spatial weights listCompute lag GDPPC\n\n\nUsing the include.self() method from spdep package modifies the existing spatial weights matrix such that each spatial unit is considered a neighbor to itself. Below is the neighbot list for polygon #1, which now has 6 neighbors instead of the original 5:\n\n\ncode block\nwm_qs <- include.self(wm_q)\nwm_qs[[1]]\n\n\n[1]  1  2  3  4 57 85\n\n\n\n\n\n\ncode block\nwm_qs <- nb2listw(wm_qs)\nwm_qs\n\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 30.90265 357.5308\n\n\n\n\n\n\ncode block\nlag_w_avg_gpdpc <- lag.listw(wm_qs, \n                             hunan$GDPPC)\nlag_w_avg_gpdpc\n\n\n [1] 24650.50 22434.17 26233.00 27084.60 26927.00 22230.17 47621.20 37160.12\n [9] 49224.71 29886.89 26627.50 22690.17 25366.40 25825.75 30329.00 32682.83\n[17] 25948.62 23987.67 25463.14 21904.38 23127.50 25949.83 20018.75 19524.17\n[25] 18955.00 17800.40 15883.00 18831.33 14832.50 17965.00 17159.89 16199.44\n[33] 18764.50 26878.75 23188.86 20788.14 12365.20 15985.00 13764.83 11907.43\n[41] 17128.14 14593.62 11644.29 12706.00 21712.29 43548.25 35049.00 16226.83\n[49] 19294.40 18156.00 19954.75 18145.17 12132.75 18419.29 14050.83 23619.75\n[57] 24552.71 24733.67 16762.60 20932.60 19467.75 18334.00 22541.00 26028.00\n[65] 29128.50 46569.00 47576.60 36545.50 20838.50 22531.00 42115.50 27619.00\n[73] 27611.33 44523.29 18127.43 28746.38 20734.50 33880.62 14716.38 28516.22\n[81] 18086.14 21244.50 29568.80 48119.71 22310.75 43151.60 17133.40 17009.33\n\n\n\n\n\n# create a list of Hunan provinces and corresponding spatial lag GDPPC values\nlag.list.wm_qs <- list(hunan$NAME_3, lag.listw(wm_qs, hunan$GDPPC))\n\n# Transform list object into dataframe\nlag_wm_qs.res <- as.data.frame(lag.list.wm_qs)\n\n# Assign column names\ncolnames(lag_wm_qs.res) <- c(\"NAME_3\", \"lag_window_avg GDPPC\")\n\n# Add to main dataframe\nhunan <- left_join(hunan, lag_wm_qs.res)\n\n\n\ncode block\nhead(hunan,10) %>%\n  kbl() %>%\n  kable_styling(\n    full_width = F, \n    bootstrap_options = c(\"condensed\", \"responsive\"))\n\n\n\n\n \n  \n    NAME_2 \n    ID_3 \n    NAME_3 \n    ENGTYPE_3 \n    County \n    GDPPC \n    lag GDPPC \n    lag_sum GDPPC \n    lag_window_avg GDPPC \n    geometry \n  \n \n\n  \n    Changde \n    21098 \n    Anxiang \n    County \n    Anxiang \n    23667 \n    24847.20 \n    124236 \n    24650.50 \n    POLYGON ((112.0625 29.75523... \n  \n  \n    Changde \n    21100 \n    Hanshou \n    County \n    Hanshou \n    20981 \n    22724.80 \n    113624 \n    22434.17 \n    POLYGON ((112.2288 29.11684... \n  \n  \n    Changde \n    21101 \n    Jinshi \n    County City \n    Jinshi \n    34592 \n    24143.25 \n    96573 \n    26233.00 \n    POLYGON ((111.8927 29.6013,... \n  \n  \n    Changde \n    21102 \n    Li \n    County \n    Li \n    24473 \n    27737.50 \n    110950 \n    27084.60 \n    POLYGON ((111.3731 29.94649... \n  \n  \n    Changde \n    21103 \n    Linli \n    County \n    Linli \n    25554 \n    27270.25 \n    109081 \n    26927.00 \n    POLYGON ((111.6324 29.76288... \n  \n  \n    Changde \n    21104 \n    Shimen \n    County \n    Shimen \n    27137 \n    21248.80 \n    106244 \n    22230.17 \n    POLYGON ((110.8825 30.11675... \n  \n  \n    Changsha \n    21109 \n    Liuyang \n    County City \n    Liuyang \n    63118 \n    43747.00 \n    174988 \n    47621.20 \n    POLYGON ((113.9905 28.5682,... \n  \n  \n    Changsha \n    21110 \n    Ningxiang \n    County \n    Ningxiang \n    62202 \n    33582.71 \n    235079 \n    37160.12 \n    POLYGON ((112.7181 28.38299... \n  \n  \n    Changsha \n    21111 \n    Wangcheng \n    County \n    Wangcheng \n    70666 \n    45651.17 \n    273907 \n    49224.71 \n    POLYGON ((112.7914 28.52688... \n  \n  \n    Chenzhou \n    21112 \n    Anren \n    County \n    Anren \n    12761 \n    32027.62 \n    256221 \n    29886.89 \n    POLYGON ((113.1757 26.82734... \n  \n\n\n\n\n\n\n\n\nComparing lag GDPPC to window average Lag GDPPC\n\n\ncode block\nw_avg_gdppc <- qtm(hunan, \"lag_window_avg GDPPC\")\ntmap_arrange(lag_gdppc, w_avg_gdppc, asp=1, ncol=2)"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#spatial-window-sum",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#spatial-window-sum",
    "title": "Hands-on Ex 2",
    "section": "13.6 Spatial window sum",
    "text": "13.6 Spatial window sum\nThis is similar to the spatial window average, but without using row-standardized weights.\n\nincluding selfCalculating Spatial WeightsCompute lag value\n\n\nPolygon #1 now has 6 neighbors instead of 5:\n\nwm_qs <- include.self(wm_q)\nb_weights <- lapply(wm_qs, function(x) 0*x + 1)\nb_weights[1]\n\n[[1]]\n[1] 1 1 1 1 1 1\n\n\n\n\n\n# Assign weights values\nb_weights2 <- nb2listw(wm_qs, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0   S1    S2\nB 88 7744 536 1072 14160\n\n\n\n\n\n\ncode block\n# Compute lag value\nw_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\n\nw_sum_gdppc.res <- as.data.frame(w_sum_gdppc)\n\ncolnames(w_sum_gdppc.res) <- c(\"NAME_3\", \"w_sum GDPPC\")\n\nhunan <- left_join(hunan, w_sum_gdppc.res)\n\n\n\n\ncode block\nhead(hunan,10) %>%\n  kbl() %>%\n  kable_styling(\n    full_width = F, \n    bootstrap_options = c(\"condensed\", \"responsive\"))\n\n\n\n\n \n  \n    NAME_2 \n    ID_3 \n    NAME_3 \n    ENGTYPE_3 \n    County \n    GDPPC \n    lag GDPPC \n    lag_sum GDPPC \n    lag_window_avg GDPPC \n    w_sum GDPPC \n    geometry \n  \n \n\n  \n    Changde \n    21098 \n    Anxiang \n    County \n    Anxiang \n    23667 \n    24847.20 \n    124236 \n    24650.50 \n    147903 \n    POLYGON ((112.0625 29.75523... \n  \n  \n    Changde \n    21100 \n    Hanshou \n    County \n    Hanshou \n    20981 \n    22724.80 \n    113624 \n    22434.17 \n    134605 \n    POLYGON ((112.2288 29.11684... \n  \n  \n    Changde \n    21101 \n    Jinshi \n    County City \n    Jinshi \n    34592 \n    24143.25 \n    96573 \n    26233.00 \n    131165 \n    POLYGON ((111.8927 29.6013,... \n  \n  \n    Changde \n    21102 \n    Li \n    County \n    Li \n    24473 \n    27737.50 \n    110950 \n    27084.60 \n    135423 \n    POLYGON ((111.3731 29.94649... \n  \n  \n    Changde \n    21103 \n    Linli \n    County \n    Linli \n    25554 \n    27270.25 \n    109081 \n    26927.00 \n    134635 \n    POLYGON ((111.6324 29.76288... \n  \n  \n    Changde \n    21104 \n    Shimen \n    County \n    Shimen \n    27137 \n    21248.80 \n    106244 \n    22230.17 \n    133381 \n    POLYGON ((110.8825 30.11675... \n  \n  \n    Changsha \n    21109 \n    Liuyang \n    County City \n    Liuyang \n    63118 \n    43747.00 \n    174988 \n    47621.20 \n    238106 \n    POLYGON ((113.9905 28.5682,... \n  \n  \n    Changsha \n    21110 \n    Ningxiang \n    County \n    Ningxiang \n    62202 \n    33582.71 \n    235079 \n    37160.12 \n    297281 \n    POLYGON ((112.7181 28.38299... \n  \n  \n    Changsha \n    21111 \n    Wangcheng \n    County \n    Wangcheng \n    70666 \n    45651.17 \n    273907 \n    49224.71 \n    344573 \n    POLYGON ((112.7914 28.52688... \n  \n  \n    Chenzhou \n    21112 \n    Anren \n    County \n    Anren \n    12761 \n    32027.62 \n    256221 \n    29886.89 \n    268982 \n    POLYGON ((113.1757 26.82734... \n  \n\n\n\n\n\n\n\n\nComparing all the plots\n\n\ncode block\nw_sum_gdppc <- qtm(hunan, \"w_sum GDPPC\")\ntmap_arrange(gdppc, lag_gdppc, lag_sum_gdppc, w_avg_gdppc, w_sum_gdppc, \n             nrow = 2, asp = 1)"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#global-morans-i",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#global-morans-i",
    "title": "Hands-on Ex 2",
    "section": "15.1 Global Moran’s I",
    "text": "15.1 Global Moran’s I\n\nThe MathThe HypothesisThe TestMonte Carlo Moran\n\n\nExcerpt from ArcGIS Pro\nThe tool conducts the following calculations to derive an Index Value, Expected Index value, z-score and p-value:\n\nCompute the mean (\\(\\mu\\)) and variance (\\(\\sigma\\)) for the variable being evaluated\nFor each feature value x, derive the deviation from the mean (d) where \\(d = x - \\mu\\)\nDeviation values d of all neighboring areas are multiplied together to create a cross-product, P\n\nIf the values in the dataset tend to cluster spatially (high values cluster near other high values; low values cluster near other low values), the Moran’s Index will be positive. When high values repel other high values, and tend to be near low values, the Index will be negative. If positive cross-product values balance negative cross-product values, the Index will tend towards zero.\nGiven the number of features in the dataset and the variance for the data values overall, the tool computes a z-score and p-value indicating whether this difference is statistically significant or not. Index values cannot be interpreted directly; they can only be interpreted within the context of the null hypothesis.\n\n\nAs an inferential statistic, Global Moran’s I tests the following hypothesis:\n\\[H_0: \\text{The variable is randomly distributed among the spatial features in the study area}\\] \\[H_1: \\text{The variable is not randomly distributed among the spatial features in the study area}\\] Interpretation of statistical significance & distribution:\n\n\n\n\n\n\n\n\n\n+ve Moran’s I\n-ve Moran’s I\n\n\n\n\np-value < 0.05(significant)\nReject \\(H_0\\)Variable is Spatially Clustered\nReject \\(H_0\\)Variable is Spatially Dispersed\n\n\np-value > 0.05(Not significant)\nAccept \\(H_0\\)Variable is randomly distributed\n\n\n\n\n\n\nThe code chunk below performs Moran’s I statistical testing using moran.test() of spdep:\n\nmoran.test(hunan$GDPPC, \n           listw = rswm_q, \n           zero.policy = TRUE, \n           na.action = na.omit)\n\n\n    Moran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n\n\nFrom the test results, p-value is < 0.05, so we reject \\(H_0\\) and conclude that the variable is not randomly distributed among the spatial features in the study area. The alternative hypothesis: greater indicates a positive spatial autocorrelation, suggestive of spatial clustering.\n\n\nThe code chunk below performs a Monte Carlo simulation of n= 1000 trials for Moran’s I statistic by using moran.mc() of spdep:\n\nset.seed(1234)\n\nbperm <- moran.mc(hunan$GDPPC, \n                listw = rswm_q, \n                nsim = 999, \n                zero.policy = TRUE, \n                na.action = na.omit)\nbperm\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n\n\nFrom the Monte Crlo simulation test results, p-value is < 0.05, so we reject \\(H_0\\) and conclude that the variable is not randomly distributed among the spatial features in the study area. The alternative hypothesis: greater indicates a positive spatial autocorrelation, suggestive of spatial clustering.\n\n\n\n\n15.1.1 Visualising the results of Monte Carlo Moran’s I Test\n\n\ncode block\n# Extract result\nsim_moran <- bperm$res\n# Calculate mean result\nsim_mean <- mean(sim_moran)\n\nset_urbn_defaults(style = \"print\")\n\nggplot(\n    data = data.frame(sim_moran),\n    aes(x = sim_moran)\n  ) +\n  geom_histogram(\n    bins = 30, \n    color = \"#FFFCF9\", \n    fill = \"#1F363D\",\n    alpha = .8\n  ) +\n  # Add mean line\n  geom_vline(\n    xintercept = sim_mean, \n    color = \"salmon\", \n    linetype = \"dashed\", \n    linewidth = 1\n  ) +\n  # Add line annotations\n  annotate(\n    \"text\", \n    x = .035, \n    y = 100, \n    label = paste(\"Mean value =\", round(sim_mean, 3)),\n    color = \"salmon\",\n    size = 3\n  ) +\n  labs(\n    title = \"Simulated Moran's I Statistic\",\n    subtitle= \"(Based on Monte-carlo Simulation of 1000 trials)\",\n    x = \"Moran's I Statistic\",\n    y = \"Frequency\"\n  ) +\n  theme(\n    panel.grid.major = element_blank()\n  )"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#gearys-c-test",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#gearys-c-test",
    "title": "Hands-on Ex 2",
    "section": "15.2 Geary’s C test",
    "text": "15.2 Geary’s C test\nBoth Moran’s I and Geary’s C are measures of spatial autocorrelation. However, Geary’s C calculation is a simpler calculation, taking the ratio of the sum of squared differences between neighboring values over the total variance. Their result statistics are also inversely related:\n\nC value close to 1 indicates no spatial autocorrelation\nC value nearer to 0 indicates positive spatial correlation\nC value nearer to 2 indicates negative spatial correlation\n\n\nThe TestMonte Carlo Geary’s\n\n\nThe code chunk below performs Geary’s C test for spatial autocorrelation by using geary.test() of spdep\n\n\ncode block\ngeary.test(hunan$GDPPC, listw = rswm_q)\n\n\n\n    Geary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rswm_q \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n\n\nFrom the test results, p-value is < 0.05, so we reject \\(H_0\\) and conclude that the variable is not randomly distributed among the spatial features in the study area. The expected value under spatial randomness (1.0000000) is greater than the observed Geary C statistic (0.6907223), suggesting a spatial pattern of dissimilarity, where dissimilar values are clustered together.\n\n\nThe code chunk below performs a Monte Carlo simulation of n= 1000 trials for Geary’s C statistic by using geary.test():\n\nset.seed(1234)\ngperm <- geary.mc(hunan$GDPPC, \n                  listw = rswm_q, \n                  nsim = 999)\ngperm\n\n\n    Monte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n\n\nFrom the test results, p-value is < 0.05, so we reject \\(H_0\\) and conclude that the variable is not randomly distributed among the spatial features in the study area. The alternative hypothesis is stated as “greater”, suggesting that the observed Geary C statistic is larger than expected under the assumption of spatial randomness, indicating a tendency for dissimilar values to be close to each other.\n\n\n\n\n15.2.1 Visualising the results of Monte Carlo Geary C’s Test\n\n\ncode block\n# Extract result\nsim_geary <- gperm$res\n# Calculate mean result\nsim_g_mean <- mean(sim_geary)\n\nset_urbn_defaults(style = \"print\")\n\nggplot(\n    data = data.frame(sim_geary),\n    aes(x = sim_geary)\n  ) +\n  geom_histogram(\n    bins = 25, \n    color = \"#FFFCF9\", \n    fill = \"#858AE3\",\n    alpha = .8\n  ) +\n  # Add mean line\n  geom_vline(\n    xintercept = sim_g_mean, \n    color = \"#3A435E\", \n    linetype = \"dashed\", \n    linewidth = 1\n  ) +\n  # Add line annotations\n  annotate(\n    \"text\", \n    x = .95, \n    y = 115, \n    label = paste(\"Mean value =\", round(sim_g_mean, 3)),\n    color = \"#3A435E\",\n    size = 3\n  ) +\n  labs(\n    title = \"Simulated Geary's C Statistic\",\n    subtitle= \"(Based on Monte-carlo Simulation of 1000 trials)\",\n    x = \"Geary's C Statistic\",\n    y = \"Frequency\"\n  ) +\n  theme(\n    panel.grid.major = element_blank()\n  )"
  },
  {
    "objectID": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#statistical-results-as-correlograms",
    "href": "Hands-on_Ex/hoe2/Hands-on_Ex02.html#statistical-results-as-correlograms",
    "title": "Hands-on Ex 2",
    "section": "15.3 Statistical results as correlograms",
    "text": "15.3 Statistical results as correlograms\n\nMoran’s I correlogramGeary’s C correlogram\n\n\nIn the code chunk below, sp.correlogram() is used to compute a 6-lag spatial correlogram of GDPPC using global spatial autocorrelation Moran’s I (method = \"I\"):\n\nMI_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order = 6, \n                        # Use Moran's I Statistic\n                          method = \"I\", \n                          style = \"W\")\nplot(MI_corr)\n\n\n\n\nPlotting the output may not provide a complete interpretation, because not all autocorrelation values are statistically significant. Hence, it is important for us to examine the full analysis report by printing out the analysis results:\n\n\ncode block\nprint(MI_corr)\n\n\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\nThe results table has multiple columns. Each row corresponds to a specific lag distance.\n\nEstimate: The observed Moran’s I statistic at each lag distance.\nExpectation: The expected Moran’s I under the assumption of spatial randomness.\nVariance: The variance of the Moran’s I statistic.\nStandard Deviate: The standard deviate of the observed Moran’s I, indicating how many standard deviations the observed value is from the expected value under spatial randomness.\nPr(I): The p-value associated with the observed Moran’s I.\nTwo-sided: Significance codes indicating the level of significance. Smaller p-values correspond to more asterisk, indicating significance.\n\n\n\n\nmethod = \"C\" uses Geary’s C Statistic instead:\n\nGC_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order = 6, \n                          method  =\"C\", \n                          style = \"W\")\nplot(GC_corr)\n\n\n\n\n\n\ncode block\nprint(GC_corr)\n\n\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"
  },
  {
    "objectID": "Hands-on_Ex/hoe3/Hands-on_Ex03.html",
    "href": "Hands-on_Ex/hoe3/Hands-on_Ex03.html",
    "title": "Hands-on Ex 3",
    "section": "",
    "text": "Spatial Interaction: Processing and Visualising Flow Data"
  },
  {
    "objectID": "Hands-on_Ex/hoe3/Hands-on_Ex03.html#extracting-data-for-study",
    "href": "Hands-on_Ex/hoe3/Hands-on_Ex03.html#extracting-data-for-study",
    "title": "Hands-on Ex 3",
    "section": "3.1 Extracting data for study",
    "text": "3.1 Extracting data for study\nFor the purpose of this exercise, we will extract commuting flows on weekday and between 6 and 9 o’clock.\n\nodbus6_9 <- odbus09 %>%\n  filter(\n    DAY_TYPE == \"WEEKDAY\"\n  ) %>%\n  filter(\n    TIME_PER_HOUR >= 6 &\n    TIME_PER_HOUR <= 9\n  ) %>%\n  group_by(\n    ORIGIN_PT_CODE,\n    DESTINATION_PT_CODE\n  ) %>%\n  summarise(\n    TRIPS = sum(TOTAL_TRIPS)\n  ) %>%\n  ungroup()\n\nDT::datatable(head(odbus6_9, 10))"
  },
  {
    "objectID": "Hands-on_Ex/hoe3/Hands-on_Ex03.html#saving-the-dataframe-as-rds",
    "href": "Hands-on_Ex/hoe3/Hands-on_Ex03.html#saving-the-dataframe-as-rds",
    "title": "Hands-on Ex 3",
    "section": "3.2 Saving the dataframe as RDS",
    "text": "3.2 Saving the dataframe as RDS\nWe will save the output in rds format for future usage:\n\nwrite_rds(odbus6_9, \"data/rds/odbus6_9.rds\")\n\nThen, import the rds file into the R environment\n\nodbus6_9 <- read_rds(\"data/rds/odbus6_9.rds\")"
  },
  {
    "objectID": "Hands-on_Ex/hoe3/Hands-on_Ex03.html#removing-intra-zonal-flows",
    "href": "Hands-on_Ex/hoe3/Hands-on_Ex03.html#removing-intra-zonal-flows",
    "title": "Hands-on Ex 3",
    "section": "6.1 Removing intra-zonal flows",
    "text": "6.1 Removing intra-zonal flows\nAs we are interested in the spatial flows between different subzones, we remove those orign/destination flows within the subzones:\n\nod_data1 <- od_data[od_data$ORIGIN_SZ!=od_data$DESTIN_SZ,]"
  },
  {
    "objectID": "Hands-on_Ex/hoe3/Hands-on_Ex03.html#creating-desire-lines",
    "href": "Hands-on_Ex/hoe3/Hands-on_Ex03.html#creating-desire-lines",
    "title": "Hands-on Ex 3",
    "section": "6.2 Creating desire lines",
    "text": "6.2 Creating desire lines\n\nDesire lines are straight lines that represent ‘origin-destination’ data that records how many people travel (or could travel) between places (points or zones)\n\nIn this code chunk, od2line() of stplanr package is used to create the desire lines:\n\nflowline <- od2line(flow = od_data1, \n                    zones = mpsz,\n                    zone_code = \"SUBZONE_C\")"
  },
  {
    "objectID": "Hands-on_Ex/hoe3/Hands-on_Ex03.html#visualising-desire-lines",
    "href": "Hands-on_Ex/hoe3/Hands-on_Ex03.html#visualising-desire-lines",
    "title": "Hands-on Ex 3",
    "section": "6.3 Visualising desire lines",
    "text": "6.3 Visualising desire lines\n\ntmap_options(check.and.fix = TRUE)\n\ntmap_mode(\"plot\")\n\ntm_shape(mpsz) +\n  tm_polygons() +\nflowline %>%  \ntm_shape() +\n  tm_lines(lwd = \"MORNING_PEAK\",\n           style = \"quantile\",\n           scale = c(0.1, 1, 3, 5, 7, 10),\n           n = 6,\n           alpha = 0.3\n  ) +\n  tm_layout(\n    frame = FALSE\n  )\n\n\n\n\nWhen the flow data is visually messy and highly skewed like the one shown above, it is wiser to focus on selected flows.\nThus, we will focus on flows greater >= 5000:\n\ntm_shape(mpsz) +\n  tm_polygons() +\nflowline %>%  \n  filter(MORNING_PEAK >= 5000) %>%\ntm_shape() +\n  tm_lines(lwd = \"MORNING_PEAK\",\n           style = \"quantile\",\n           scale = c(0.1, 1, 3, 5, 7, 10),\n           n = 6,\n           alpha = 0.3\n  ) +\n  tm_compass(\n    type=\"8star\", size = 2\n  ) +\n  tm_layout(\n    frame = FALSE\n  ) +\n  tmap_style(\"classic\")"
  },
  {
    "objectID": "In-class_Ex/ice1/In-class_Ex01.html",
    "href": "In-class_Ex/ice1/In-class_Ex01.html",
    "title": "In-class Ex 01",
    "section": "",
    "text": "The following code chunk loads the necessary packages:\n\ntmap: for thematic mapping\nsf: for geospatial data handling\ntidyverse: for aspatial data transformation\n\n\npacman::p_load(tmap, sf, tidyverse)"
  },
  {
    "objectID": "In-class_Ex/ice1/In-class_Ex01.html#extracting-the-data-for-analysis",
    "href": "In-class_Ex/ice1/In-class_Ex01.html#extracting-the-data-for-analysis",
    "title": "In-class Ex 01",
    "section": "Extracting the data for Analysis",
    "text": "Extracting the data for Analysis\nCreate a new dataframe origtrip_7_9 by extracting Origin busstop codes and number of trips for weekdays between 7 and 9 o’clock:\n\norigtrip_7_9 <- odbus08 %>%\n  filter(\n    DAY_TYPE == \"WEEKDAY\"\n  ) %>%\n  filter(\n    TIME_PER_HOUR >= 7 & TIME_PER_HOUR <= 9\n  ) %>%\n  group_by(\n    ORIGIN_PT_CODE\n  ) %>%\n  summarise(\n    TRIPS = sum(TOTAL_TRIPS)\n  ) %>%\n  ungroup()"
  },
  {
    "objectID": "In-class_Ex/ice1/In-class_Ex01.html#loading-the-geospatial-data",
    "href": "In-class_Ex/ice1/In-class_Ex01.html#loading-the-geospatial-data",
    "title": "In-class Ex 01",
    "section": "Loading the geospatial data",
    "text": "Loading the geospatial data\n\nbusstop <- st_read(\n    dsn = \"data/geospatial\",\n    layer = \"BusStop\"\n  ) %>%\n  # Assigning the right EPSG code based on coordinate system\n  st_transform(\n    crs = 3414\n  )\n\nReading layer `BusStop' from data source \n  `C:\\haileycsy\\ISSS624-AGA\\In-class_Ex\\ice1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 5161 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3970.122 ymin: 26482.1 xmax: 48284.56 ymax: 52983.82\nProjected CRS: SVY21\n\n\n\nmpsz <- st_read(\n    dsn = \"data/geospatial\",\n    layer = \"MPSZ-2019\"\n  ) %>%\n # Assigning the right EPSG code\n  st_transform(\n    crs = 3414\n  )\n\nReading layer `MPSZ-2019' from data source \n  `C:\\haileycsy\\ISSS624-AGA\\In-class_Ex\\ice1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 332 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 103.6057 ymin: 1.158699 xmax: 104.0885 ymax: 1.470775\nGeodetic CRS:  WGS 84"
  },
  {
    "objectID": "In-class_Ex/ice1/MPSZ-2019.html",
    "href": "In-class_Ex/ice1/MPSZ-2019.html",
    "title": "haileycsy",
    "section": "",
    "text": "<!DOCTYPE qgis PUBLIC ‘http://mrcc.com/qgis.dtd’ ‘SYSTEM’>     dataset\n\n\n        0 0     false"
  },
  {
    "objectID": "In-class_Ex/ice2/In-class_Ex02.html",
    "href": "In-class_Ex/ice2/In-class_Ex02.html",
    "title": "In-class Ex 2",
    "section": "",
    "text": "Geospatial Analysis using sfdep"
  },
  {
    "objectID": "In-class_Ex/ice2/In-class_Ex02.html#joining-the-dataframes",
    "href": "In-class_Ex/ice2/In-class_Ex02.html#joining-the-dataframes",
    "title": "In-class Ex 2",
    "section": "2.1 Joining the dataframes",
    "text": "2.1 Joining the dataframes\nSpatial features are added to the attribute dataframe as geometry column:\n\nhunan_GDPPC<- left_join(hunan, \n                         GDPPC, \n                         by = \"County\")\n\nglimpse(hunan_GDPPC)\n\nRows: 1,496\nColumns: 10\n$ NAME_2     <chr> \"Changde\", \"Changde\", \"Changde\", \"Changde\", \"Changde\", \"Cha…\n$ ID_3       <int> 21098, 21098, 21098, 21098, 21098, 21098, 21098, 21098, 210…\n$ NAME_3     <chr> \"Anxiang\", \"Anxiang\", \"Anxiang\", \"Anxiang\", \"Anxiang\", \"Anx…\n$ ENGTYPE_3  <chr> \"County\", \"County\", \"County\", \"County\", \"County\", \"County\",…\n$ Shape_Leng <dbl> 1.869074, 1.869074, 1.869074, 1.869074, 1.869074, 1.869074,…\n$ Shape_Area <dbl> 0.1005619, 0.1005619, 0.1005619, 0.1005619, 0.1005619, 0.10…\n$ County     <chr> \"Anxiang\", \"Anxiang\", \"Anxiang\", \"Anxiang\", \"Anxiang\", \"Anx…\n$ Year       <dbl> 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014,…\n$ GDPPC      <dbl> 8184.00, 10995.00, 12670.00, 14128.00, 16763.00, 19817.00, …\n$ geometry   <POLYGON [°]> POLYGON ((112.0625 29.75523..., POLYGON ((112.0625 …"
  },
  {
    "objectID": "In-class_Ex/ice2/In-class_Ex02.html#confirm-if-the-new-dataframe-is-a-spacetime-cube-object",
    "href": "In-class_Ex/ice2/In-class_Ex02.html#confirm-if-the-new-dataframe-is-a-spacetime-cube-object",
    "title": "In-class Ex 2",
    "section": "6.1 Confirm if the new dataframe is a spacetime cube object",
    "text": "6.1 Confirm if the new dataframe is a spacetime cube object\n\nis_spacetime_cube(GDPPC_st)\n\n[1] TRUE"
  },
  {
    "objectID": "In-class_Ex/ice3/data/geospatial/MPSZ-2019.html",
    "href": "In-class_Ex/ice3/data/geospatial/MPSZ-2019.html",
    "title": "haileycsy",
    "section": "",
    "text": "<!DOCTYPE qgis PUBLIC ‘http://mrcc.com/qgis.dtd’ ‘SYSTEM’>     dataset\n\n\n        0 0     false"
  },
  {
    "objectID": "In-class_Ex/ice3/In-class_Ex03.html",
    "href": "In-class_Ex/ice3/In-class_Ex03.html",
    "title": "In-class Ex 3",
    "section": "",
    "text": "Spatial Interaction Models\nSpatial Interaction Models (SIMs) are mathematical models for estimating flows between spatial entities developed by Alan Wilson in the late 1960s and early 1970, with considerable uptake and refinement for transport modelling since then Boyce and Williams (2015).\nThere are four main types of traditional SIMs (Wilson 1971):\nCalibrating Flows:\nOrdinary least square (OLS), log-normal, Poisson and negative binomial (NB) regression methods have been used extensively to calibrate OD flow models by processing flow data as different types of dependent variables. This exercise will focus on using appropriate R packages to calibrate SIMs by using the four regression methods."
  },
  {
    "objectID": "In-class_Ex/ice3/In-class_Ex03.html#mpsz",
    "href": "In-class_Ex/ice3/In-class_Ex03.html#mpsz",
    "title": "In-class Ex 3",
    "section": "2.1 mpsz",
    "text": "2.1 mpsz\n\nImport RDSConverting from sf data.table to SpatialPolygonsDataFrame\n\n\n\nmpsz <- read_rds(\"data/rds/mpsz.rds\")\nmpsz\n\nSimple feature collection with 332 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\nFirst 10 features:\n                 SUBZONE_N SUBZONE_C       PLN_AREA_N PLN_AREA_C       REGION_N\n1              MARINA EAST    MESZ01      MARINA EAST         ME CENTRAL REGION\n2         INSTITUTION HILL    RVSZ05     RIVER VALLEY         RV CENTRAL REGION\n3           ROBERTSON QUAY    SRSZ01  SINGAPORE RIVER         SR CENTRAL REGION\n4  JURONG ISLAND AND BUKOM    WISZ01  WESTERN ISLANDS         WI    WEST REGION\n5             FORT CANNING    MUSZ02           MUSEUM         MU CENTRAL REGION\n6         MARINA EAST (MP)    MPSZ05    MARINE PARADE         MP CENTRAL REGION\n7                   SUDONG    WISZ03  WESTERN ISLANDS         WI    WEST REGION\n8                  SEMAKAU    WISZ02  WESTERN ISLANDS         WI    WEST REGION\n9           SOUTHERN GROUP    SISZ02 SOUTHERN ISLANDS         SI CENTRAL REGION\n10                 SENTOSA    SISZ01 SOUTHERN ISLANDS         SI CENTRAL REGION\n   REGION_C                       geometry\n1        CR MULTIPOLYGON (((33222.98 29...\n2        CR MULTIPOLYGON (((28481.45 30...\n3        CR MULTIPOLYGON (((28087.34 30...\n4        WR MULTIPOLYGON (((14557.7 304...\n5        CR MULTIPOLYGON (((29542.53 31...\n6        CR MULTIPOLYGON (((35279.55 30...\n7        WR MULTIPOLYGON (((15772.59 21...\n8        WR MULTIPOLYGON (((19843.41 21...\n9        CR MULTIPOLYGON (((30870.53 22...\n10       CR MULTIPOLYGON (((26879.04 26...\n\n\n\n\nas_Spatial() will be used to convert mpsz from sf tibble data frame to a SpatialPolygonsDataFrame (sp object)\n\nmpsz_sp <- mpsz %>%\n  as_Spatial()\n\nmpsz_sp\n\nclass       : SpatialPolygonsDataFrame \nfeatures    : 332 \nextent      : 2667.538, 56396.44, 15748.72, 50256.33  (xmin, xmax, ymin, ymax)\ncrs         : +proj=tmerc +lat_0=1.36666666666667 +lon_0=103.833333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs \nvariables   : 6\nnames       : SUBZONE_N, SUBZONE_C, PLN_AREA_N, PLN_AREA_C,       REGION_N, REGION_C \nmin values  : ADMIRALTY,    AMSZ01, ANG MO KIO,         AM, CENTRAL REGION,       CR \nmax values  :    YUNNAN,    YSSZ09,     YISHUN,         YS,    WEST REGION,       WR"
  },
  {
    "objectID": "In-class_Ex/ice3/In-class_Ex03.html#creating-distance-matrix-frame",
    "href": "In-class_Ex/ice3/In-class_Ex03.html#creating-distance-matrix-frame",
    "title": "In-class Ex 3",
    "section": "3.1 Creating distance matrix frame",
    "text": "3.1 Creating distance matrix frame\nspDists() of sp package will be used to compute the Euclidean distance between the centroids of the planning subzones.\nCentroids of each planning subzones are used as points of origin and destination for easy calculations.\n\ndist <- spDists(mpsz_sp, \n                # df is already polygon, so set longlat as FALSE\n                longlat = FALSE)\n\n\nhead(dist, n=c(10, 10))\n\n           [,1]       [,2]      [,3]      [,4]       [,5]      [,6]      [,7]\n [1,]     0.000  3926.0025  3939.108 20252.964  2989.9839  1431.330 19211.836\n [2,]  3926.003     0.0000   305.737 16513.865   951.8314  5254.066 16242.523\n [3,]  3939.108   305.7370     0.000 16412.062  1045.9088  5299.849 16026.146\n [4,] 20252.964 16513.8648 16412.062     0.000 17450.3044 21665.795  7229.017\n [5,]  2989.984   951.8314  1045.909 17450.304     0.0000  4303.232 17020.916\n [6,]  1431.330  5254.0664  5299.849 21665.795  4303.2323     0.000 20617.082\n [7,] 19211.836 16242.5230 16026.146  7229.017 17020.9161 20617.082     0.000\n [8,] 14960.942 12749.4101 12477.871 11284.279 13336.0421 16281.453  5606.082\n [9,]  7515.256  7934.8082  7649.776 18427.503  7801.6163  8403.896 14810.930\n[10,]  6391.342  4975.0021  4669.295 15469.566  5226.8731  7707.091 13111.391\n           [,8]      [,9]     [,10]\n [1,] 14960.942  7515.256  6391.342\n [2,] 12749.410  7934.808  4975.002\n [3,] 12477.871  7649.776  4669.295\n [4,] 11284.279 18427.503 15469.566\n [5,] 13336.042  7801.616  5226.873\n [6,] 16281.453  8403.896  7707.091\n [7,]  5606.082 14810.930 13111.391\n [8,]     0.000  9472.024  8575.490\n [9,]  9472.024     0.000  3780.800\n[10,]  8575.490  3780.800     0.000\n\n\nThe resultant distance matrix shows the relative distances between each subzone centroid."
  },
  {
    "objectID": "In-class_Ex/ice3/In-class_Ex03.html#labelling-column-and-row-headers",
    "href": "In-class_Ex/ice3/In-class_Ex03.html#labelling-column-and-row-headers",
    "title": "In-class Ex 3",
    "section": "3.2 Labelling column and row headers",
    "text": "3.2 Labelling column and row headers\n\nSort by sub-zone codeAttach Subzone names\n\n\nWe first create a list, sz_names, sorted according to the the distance matrix by planning sub-zone code:\n\nsz_names <- mpsz$SUBZONE_C\n\n\n\nNext, we assign SUBZONE_C to rows and columns for distance matrix matching\n\ncolnames(dist) <- paste0(sz_names)\nrownames(dist) <- paste0(sz_names)\n\n\nhead(dist, n=c(10, 10))\n\n          MESZ01     RVSZ05    SRSZ01    WISZ01     MUSZ02    MPSZ05    WISZ03\nMESZ01     0.000  3926.0025  3939.108 20252.964  2989.9839  1431.330 19211.836\nRVSZ05  3926.003     0.0000   305.737 16513.865   951.8314  5254.066 16242.523\nSRSZ01  3939.108   305.7370     0.000 16412.062  1045.9088  5299.849 16026.146\nWISZ01 20252.964 16513.8648 16412.062     0.000 17450.3044 21665.795  7229.017\nMUSZ02  2989.984   951.8314  1045.909 17450.304     0.0000  4303.232 17020.916\nMPSZ05  1431.330  5254.0664  5299.849 21665.795  4303.2323     0.000 20617.082\nWISZ03 19211.836 16242.5230 16026.146  7229.017 17020.9161 20617.082     0.000\nWISZ02 14960.942 12749.4101 12477.871 11284.279 13336.0421 16281.453  5606.082\nSISZ02  7515.256  7934.8082  7649.776 18427.503  7801.6163  8403.896 14810.930\nSISZ01  6391.342  4975.0021  4669.295 15469.566  5226.8731  7707.091 13111.391\n          WISZ02    SISZ02    SISZ01\nMESZ01 14960.942  7515.256  6391.342\nRVSZ05 12749.410  7934.808  4975.002\nSRSZ01 12477.871  7649.776  4669.295\nWISZ01 11284.279 18427.503 15469.566\nMUSZ02 13336.042  7801.616  5226.873\nMPSZ05 16281.453  8403.896  7707.091\nWISZ03  5606.082 14810.930 13111.391\nWISZ02     0.000  9472.024  8575.490\nSISZ02  9472.024     0.000  3780.800\nSISZ01  8575.490  3780.800     0.000\n\n\nThe resultant distance matrix now has planning subzone code as row and column labels."
  },
  {
    "objectID": "In-class_Ex/ice3/In-class_Ex03.html#dealing-with-0-value-intra-zonal-distances",
    "href": "In-class_Ex/ice3/In-class_Ex03.html#dealing-with-0-value-intra-zonal-distances",
    "title": "In-class Ex 3",
    "section": "3.3 Dealing with 0-value intra-zonal distances",
    "text": "3.3 Dealing with 0-value intra-zonal distances\nThe diagonals of the distance matrix are 0, and represent intra-zonal distances. We append a constant value to replace the intra-zonal distance of 0.\n\nPivot by SUBZONE_CFind minimum distanceAssign constant as intra-zonal distance\n\n\n\ndistPair <- melt(dist) %>%\n  rename(dist = value,\n         orig = Var1,\n         dest = Var2\n)\n\nhead(distPair, 10)\n\n     orig   dest      dist\n1  MESZ01 MESZ01     0.000\n2  RVSZ05 MESZ01  3926.003\n3  SRSZ01 MESZ01  3939.108\n4  WISZ01 MESZ01 20252.964\n5  MUSZ02 MESZ01  2989.984\n6  MPSZ05 MESZ01  1431.330\n7  WISZ03 MESZ01 19211.836\n8  WISZ02 MESZ01 14960.942\n9  SISZ02 MESZ01  7515.256\n10 SISZ01 MESZ01  6391.342\n\n\n\n\nselect and find out the minimum value of the distance by using summary()\n\ndistPair %>%\n  filter(dist > 0) %>%\n  summary()\n\n      orig             dest             dist        \n MESZ01 :   331   MESZ01 :   331   Min.   :  173.8  \n RVSZ05 :   331   RVSZ05 :   331   1st Qu.: 7149.5  \n SRSZ01 :   331   SRSZ01 :   331   Median :11890.0  \n WISZ01 :   331   WISZ01 :   331   Mean   :12229.4  \n MUSZ02 :   331   MUSZ02 :   331   3rd Qu.:16401.7  \n MPSZ05 :   331   MPSZ05 :   331   Max.   :49894.4  \n (Other):107906   (Other):107906                    \n\n\nThe minimum distance recorded is 173.8\n\n\nNext, a constant distance value of 50m is assigned to intra-zonal distance\n\ndistPair$dist <- ifelse(distPair$dist == 0,\n                        50, distPair$dist)\n\n\nsummary(distPair)\n\n      orig             dest             dist      \n MESZ01 :   332   MESZ01 :   332   Min.   :   50  \n RVSZ05 :   332   RVSZ05 :   332   1st Qu.: 7097  \n SRSZ01 :   332   SRSZ01 :   332   Median :11864  \n WISZ01 :   332   WISZ01 :   332   Mean   :12193  \n MUSZ02 :   332   MUSZ02 :   332   3rd Qu.:16388  \n MPSZ05 :   332   MPSZ05 :   332   Max.   :49894  \n (Other):108232   (Other):108232                  \n\n\nThe minimum distance recorded is 50, our intra-zonal distance."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "haileycsy",
    "section": "",
    "text": "AppliedGeospatialAnalytics"
  },
  {
    "objectID": "Take-home_Ex/the1/data/geospatial/hexagon.html",
    "href": "Take-home_Ex/the1/data/geospatial/hexagon.html",
    "title": "haileycsy",
    "section": "",
    "text": "<!DOCTYPE qgis PUBLIC ‘http://mrcc.com/qgis.dtd’ ‘SYSTEM’>     dataset\n\n\n                 +proj=tmerc +lat_0=1.36666666666667 +lon_0=103.833333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs 0 0     false"
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html",
    "href": "Take-home_Ex/the1/Take-home_ex1.html",
    "title": "Take-home Ex 1",
    "section": "",
    "text": "Spatio-temporal Patterns of Public Bus Ridership"
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#aspatial-data",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#aspatial-data",
    "title": "Take-home Ex 1",
    "section": "3.1 Aspatial Data",
    "text": "3.1 Aspatial Data\nA dataset from LTA Datamall, Passenger Volume by Origin Destination Bus Stops from August to October 2023 is used to compute bus traffic. As these were downloaded as separate .csv files, they are imported and combined into a single dataframe.\n\nImporting csv filesVariable DescriptionSummary Statistics\n\n\n\n\ncode block\n# Load each csv file into R separately\nbus08 <- read_csv(\"data/aspatial/origin_destination_bus_202308.csv\")\nbus09 <- read_csv(\"data/aspatial/origin_destination_bus_202309.csv\")\nbus10 <- read_csv(\"data/aspatial/origin_destination_bus_202310.csv\")\n\n# Combine all rows into single dataframe\nbusod <- rbind(bus08, bus09, bus10)\n\nstr(busod)\n\n\nspc_tbl_ [17,118,005 × 7] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ YEAR_MONTH         : chr [1:17118005] \"2023-08\" \"2023-08\" \"2023-08\" \"2023-08\" ...\n $ DAY_TYPE           : chr [1:17118005] \"WEEKDAY\" \"WEEKENDS/HOLIDAY\" \"WEEKENDS/HOLIDAY\" \"WEEKDAY\" ...\n $ TIME_PER_HOUR      : num [1:17118005] 16 16 14 14 17 17 17 17 7 17 ...\n $ PT_TYPE            : chr [1:17118005] \"BUS\" \"BUS\" \"BUS\" \"BUS\" ...\n $ ORIGIN_PT_CODE     : chr [1:17118005] \"04168\" \"04168\" \"80119\" \"80119\" ...\n $ DESTINATION_PT_CODE: chr [1:17118005] \"10051\" \"10051\" \"90079\" \"90079\" ...\n $ TOTAL_TRIPS        : num [1:17118005] 7 2 3 10 5 4 3 22 3 3 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   YEAR_MONTH = col_character(),\n  ..   DAY_TYPE = col_character(),\n  ..   TIME_PER_HOUR = col_double(),\n  ..   PT_TYPE = col_character(),\n  ..   ORIGIN_PT_CODE = col_character(),\n  ..   DESTINATION_PT_CODE = col_character(),\n  ..   TOTAL_TRIPS = col_double()\n  .. )\n - attr(*, \"problems\")=<externalptr> \n\n\n\n\nbusod is a tibble dataframe consisting of the following variables:\n\nYEAR_MONTH: Month of data collection in YYYY-MM format\nDAY_TYPE: Category of Day\nTIME_PER_HOUR: Extracted hour of day\nPT_TYPE: Public transport type\nORIGIN_PT_CODE: ID of Trip Origin Bus Stop\nDESTINATION_PT_CODE: ID of Trip Destination Bus Stop\nTOTAL_TRIPS: Sum of trips made per origin-Destination\n\n\n\ncode block\nhead(busod,10) %>%\n  kbl() %>%\n  kable_styling(\n    full_width = F, \n    bootstrap_options = c(\"condensed\", \"responsive\"))\n\n\n\n\n \n  \n    YEAR_MONTH \n    DAY_TYPE \n    TIME_PER_HOUR \n    PT_TYPE \n    ORIGIN_PT_CODE \n    DESTINATION_PT_CODE \n    TOTAL_TRIPS \n  \n \n\n  \n    2023-08 \n    WEEKDAY \n    16 \n    BUS \n    04168 \n    10051 \n    7 \n  \n  \n    2023-08 \n    WEEKENDS/HOLIDAY \n    16 \n    BUS \n    04168 \n    10051 \n    2 \n  \n  \n    2023-08 \n    WEEKENDS/HOLIDAY \n    14 \n    BUS \n    80119 \n    90079 \n    3 \n  \n  \n    2023-08 \n    WEEKDAY \n    14 \n    BUS \n    80119 \n    90079 \n    10 \n  \n  \n    2023-08 \n    WEEKENDS/HOLIDAY \n    17 \n    BUS \n    44069 \n    17229 \n    5 \n  \n  \n    2023-08 \n    WEEKDAY \n    17 \n    BUS \n    44069 \n    17229 \n    4 \n  \n  \n    2023-08 \n    WEEKENDS/HOLIDAY \n    17 \n    BUS \n    20281 \n    20141 \n    3 \n  \n  \n    2023-08 \n    WEEKDAY \n    17 \n    BUS \n    20281 \n    20141 \n    22 \n  \n  \n    2023-08 \n    WEEKDAY \n    7 \n    BUS \n    19051 \n    10017 \n    3 \n  \n  \n    2023-08 \n    WEEKENDS/HOLIDAY \n    17 \n    BUS \n    11169 \n    04219 \n    3 \n  \n\n\n\n\n\n\n\n\nsummary(busod)\n\n  YEAR_MONTH          DAY_TYPE         TIME_PER_HOUR     PT_TYPE         \n Length:17118005    Length:17118005    Min.   : 0.00   Length:17118005   \n Class :character   Class :character   1st Qu.:10.00   Class :character  \n Mode  :character   Mode  :character   Median :14.00   Mode  :character  \n                                       Mean   :14.06                     \n                                       3rd Qu.:18.00                     \n                                       Max.   :23.00                     \n ORIGIN_PT_CODE     DESTINATION_PT_CODE  TOTAL_TRIPS      \n Length:17118005    Length:17118005     Min.   :    1.00  \n Class :character   Class :character    1st Qu.:    2.00  \n Mode  :character   Mode  :character    Median :    4.00  \n                                        Mean   :   20.46  \n                                        3rd Qu.:   12.00  \n                                        Max.   :36668.00  \n\n\n\nSummary Statistics reveal that:\n\nThere are 17,118,005 bus trip combinations recorded over 3 months\nDAY_TYPE is split into only 2 categories, ‘WEEKDAY’ and ‘WEEKENDS/PUBLIC HOLIDAY’\nData is collected for 24 hours, starting from 0 Hrs to 23 Hrs in TIME_PER_HOUR\nThere are 5075 distinct origin bus stops, and 5079 distinct destination stops\nThe average number of trips per route is 20.46, with the highest value recorded being a whopping 36,668 – this points to the presence of possible outliers or anomalies, that may be cause for further analysis"
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#geospatial-data",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#geospatial-data",
    "title": "Take-home Ex 1",
    "section": "3.2 Geospatial Data",
    "text": "3.2 Geospatial Data\nThere is one source of Geospatial data used in this study:\n\nBus Stop Location from LTA DataMall, providing information about all the bus stops currently being serviced by buses including the bus stop code (identifier) and location coordinates\n\n\nImporting Geospatial FilesCheck EPSG Code and CRSAssigning the right EPSG Code based on CRS\n\n\nbusstop is a Simple feature layers are based on SVY21 coordinate reference system (CRS).\n\n\ncode block\nbusstop <- st_read(\n    dsn = \"data/geospatial\",\n    layer = \"BusStop\"\n  ) \n\n\nReading layer `BusStop' from data source \n  `C:\\haileycsy\\ISSS624-AGA\\Take-home_Ex\\the1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 5161 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3970.122 ymin: 26482.1 xmax: 48284.56 ymax: 52983.82\nProjected CRS: SVY21\n\n\nThis geospatial layer shows the point location of busstops in Singapore:\n\nqtm(busstop)\n\n\n\n\n\n\nThe st_crs() function is used to check for ESPG Code and Coordinate System of both geospatial files. In order to perform geoprocessing using different geospatial data sources, both need to be projected using similar coordinate systems and be assigned the correct EPSG code based on CRS.\n\nst_crs(busstop)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"WGS 84\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\n\nAccording to epsg.io, Singapore’s coordinate system is SVY21 with EPSG 3414\n\nbusstop is projected in SVY21 with EPSG 9001 – this will require re-assignment of EPSG code to 3414\n\n\n\n\nThis is done using the st_set_crs() function\n\n# Assign EPSG code\nbusstop <- st_set_crs(\n   busstop, \n   3414\n  ) %>%\n# rename bus stop origin for easy join to main dataframe\n  mutate(\n    ORIGIN_PT_CODE = as.factor(BUS_STOP_N)\n  ) %>%\n  select(\n    ORIGIN_PT_CODE, \n    LOC_DESC,\n    geometry\n  ) %>%\n  # change all column names to lowercase\n  rename_with(\n    tolower, everything()\n  )\n# Confirm EPSG code\nst_crs(busstop)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\nbusstop is now assigned the correct EPSG code."
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#aspatial-data-preparation",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#aspatial-data-preparation",
    "title": "Take-home Ex 1",
    "section": "4.1 Aspatial Data Preparation",
    "text": "4.1 Aspatial Data Preparation\n\nChanging Data TypeCreate Categorical Variable for Periods of study\n\n\nORIGIN_PT_CODE and DESTINATION_PT_CODE are in character format. These represent the busstop locations, and are thus transformed into factors (categorical data type) for further analysis\n\nbusod <- busod %>%\n  mutate(\n    ORIGIN_PT_CODE = as.factor(ORIGIN_PT_CODE),\n    DESTINATION_PT_CODE = as.factor(DESTINATION_PT_CODE)\n  )\n\n\n\nThe following code chunk involves multiple steps to prepare the relevant data needed for further analysis:\n\nCategorize trips by peak period based on day and time by creating a new categorical variable, period, and filtering the data using nested ifelse() conditions\nfilter() out non peak periods\nCompute number of trips per origin busstop per month for each period using group_by() and summarise()\n\n\nbusod_agg <- busod %>%\n  # Categorize trips under period based on day and timeframe\n  mutate(period = ifelse(DAY_TYPE == \"WEEKDAY\" & \n                         TIME_PER_HOUR >= 6 & TIME_PER_HOUR <= 9, \n                         \"Weekday morning peak\",\n                    ifelse(DAY_TYPE == \"WEEKDAY\" & \n                           TIME_PER_HOUR >= 17 & TIME_PER_HOUR <= 20,\n                           \"Weekday evening peak\",\n                      ifelse(DAY_TYPE == \"WEEKENDS/HOLIDAY\" &\n                             TIME_PER_HOUR >= 11 & TIME_PER_HOUR <= 14,\n                              \"Weekend/PH morning peak\",\n                        ifelse(DAY_TYPE == \"WEEKENDS/HOLIDAY\" & \n                              TIME_PER_HOUR >= 16 & TIME_PER_HOUR <= 19,\n                               \"Weekend/PH evening peak\",\n                    \"Others\"))))\n  ) %>%\n  # Only retain needed periods for analysis\n  filter(\n    period != \"Others\"\n  ) %>%\n # compute number of trips per origin busstop per month for each period\n  group_by(\n    YEAR_MONTH,\n    period,\n    ORIGIN_PT_CODE\n  ) %>%\n  summarise(\n    num_trips = sum(TOTAL_TRIPS)\n  ) %>%\n  # change all column names to lowercase\n  rename_with(\n    tolower, everything()\n  ) %>%\n  ungroup()"
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#fa-bus-does-this-distribution-change-over-time",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#fa-bus-does-this-distribution-change-over-time",
    "title": "Take-home Ex 1",
    "section": "5.1  Does this distribution change over time?",
    "text": "5.1  Does this distribution change over time?\nTo understand if this distribution is unique to the month of August, or records similar trends throughout the months, the distribution of passenger traffic across peak periods over 3 months is compared:\n\n\ncode block\nbus_density <- busod_agg %>%\n  ggplot(\n    aes(x = period,\n        y = num_trips,\n        fill = period,\n        color = period)\n  ) +\n  geom_violin(\n    position = position_nudge(x = .2, y = 0), alpha = .8\n  ) +\n  geom_point(\n    aes(y = num_trips, \n        color = period), \n    position = position_jitter(width = .15),\n    size = .5, \n    alpha = 0.8\n  ) +\n  geom_boxplot(\n    width = .1, \n    outlier.shape = NA, \n    alpha = 0.5\n  ) +\n  facet_wrap(~year_month, \n             nrow = 1\n  ) +\n  scale_y_continuous(\n    labels = scales::number_format(accuracy = 1),\n    breaks = scales::pretty_breaks(n = 3)\n  ) +\n  labs(\n    title = \"Aug - Oct 2023: Similar distributions of Passenger Traffic\"\n  ) + \n  theme(\n    axis.title.y = element_blank(),\n    axis.title.x = element_blank(),\n    axis.ticks.y = element_blank(),\n    axis.ticks.x = element_blank(),\n    legend.position = \"none\"\n  ) +\n  coord_flip()\n\nbus_density\n\n\n\n\n\nThe density plots above reveal that the distribution of number of trips recorded over a 3-month period are very similar. It is thus reasonable to deduce that there are several bus stops with very high passenger volume, especially on weekday evening peak periods – if these bus stops are within close proximity to each other, it could point towards possible hot spots for traffic congestion.\nAs the trend does not change significantly over the months, further geospatial analysis is conducted on August 2023 passenger traffic data to locate these potential hot spots."
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#extracting-specific-data-for-study",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#extracting-specific-data-for-study",
    "title": "Take-home Ex 1",
    "section": "5.2 Extracting Specific data for study",
    "text": "5.2 Extracting Specific data for study\nAugust 2023 Passenger volume data is filtered out using the following code, and a pivot table is created such that each row represents a single bus stop:\n\n# Extract august data and store as separate dataframe\nbusod_08 <- busod_agg %>%\n  filter(\n    year_month == \"2023-08\"\n  ) %>%\n  # get each row as a bus stop code with peak period trips as columns\n  pivot_wider(\n    names_from = period,\n    values_from = num_trips\n  ) %>%\n  select(2:6)\n\nDT::datatable(busod_08,\n              options = list(pageLength = 8),\n              rownames = FALSE)"
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#creating-spatial-polygon-dataframe",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#creating-spatial-polygon-dataframe",
    "title": "Take-home Ex 1",
    "section": "5.3 Creating Spatial Polygon Dataframe",
    "text": "5.3 Creating Spatial Polygon Dataframe\n\nJoin Aspatial to Geospatial point dataframeCreating Hexagon Spatial Dataframe\n\n\nUsing left_join to map busstops by bus stop code\n\nbusod_08_sf <- left_join(busstop, busod_08, by = \"origin_pt_code\")\n\nbusod_08_sf\n\nSimple feature collection with 5161 features and 6 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3970.122 ymin: 26482.1 xmax: 48284.56 ymax: 52983.82\nProjected CRS: SVY21 / Singapore TM\nFirst 10 features:\n   origin_pt_code             loc_desc Weekday evening peak\n1           22069   OPP CEVA LOGISTICS                   43\n2           32071         AFT TRACK 13                   NA\n3           44331              BLK 239                 1742\n4           96081 GRACE INDEPENDENT CH                  399\n5           11561              BLK 166                  195\n6           66191         AFT CORFE PL                  362\n7           23389              PEC LTD                  406\n8           54411              BLK 527                 1314\n9           28531              BLK 536                 3789\n10          96139              BLK 148                 1420\n   Weekday morning peak Weekend/PH evening peak Weekend/PH morning peak\n1                    15                      12                       6\n2                    NA                       1                      NA\n3                  2124                     546                     700\n4                   307                      84                     110\n5                   190                      61                      81\n6                   399                     173                     158\n7                    35                      84                      10\n8                  3112                     497                    1436\n9                  9258                    1873                    1970\n10                 5030                     710                     858\n                    geometry\n1  POINT (13576.31 32883.65)\n2  POINT (13228.59 44206.38)\n3   POINT (21045.1 40242.08)\n4  POINT (41603.76 35413.11)\n5  POINT (24568.74 30391.85)\n6  POINT (30951.58 38079.61)\n7    POINT (12476.9 32211.6)\n8  POINT (30329.45 39373.92)\n9  POINT (14993.31 36905.61)\n10  POINT (41642.81 36513.9)\n\n\n\n\nbusod_08_sf is a spatial point dataframe. This is not particularly useful when dealing with spatial autocorrelation analysis, as ‘areas’ need to be defined as planes in space (polygons instead of points). The following code chunks place these bus stops into a hexagon grid:\n\nStep 1: Create a hexagon grid frame\n\nUse the st_make_grid() function\ncellsize argument units are the same as the dataframe’s. As busod_08_sf is projected in ESPG code 3414, the unit is in meters and defines the width of the hexagon. This is set to 500m.\nAssign a hex_id to each hexagon as primary key\n\noutput: Spatial polygons, with hex_id and geometry data\n\n\nbusod_08_hex <- st_make_grid(\n    busod_08_sf,\n    cellsize = 500,\n    square = FALSE\n  ) %>%\n  st_sf() %>%\n  rowid_to_column(\"hex_id\")\n\n\nStep 2: Create Attribute dataframe using hex id instead of busstop code\nAs each hexagon area may contain more than a single bus stop, we need to use hex_id as primary key. The following steps are taken to group the attributes by hex_id:\n\nUse the st_join() function with join = st_within to place busstop points within the hexagon areas\nst_set_grometry(NULL) argument removes the geospatial layer\ngroup_by() to get unique hex_id per row\nsummarise() to compute the aggregate number of bus stops and trips per peak period for each hexagon area\nreplace(is.na(.), 0) replaces all NA values with 0\n\noutput: Aspatial Attributes dataframe, with hex_id as primary key\n\n\nbusod_08_stops <- st_join(\n  busod_08_sf, \n  busod_08_hex, \n  join = st_within\n  ) %>%\n  st_set_geometry(NULL) %>%\n  group_by(\n    hex_id\n  ) %>%\n  summarise(\n    n_busstops = n(),\n    busstop_codes = str_c(origin_pt_code, collapse = \",\"),\n    `Weekday morning peak` = sum(`Weekday morning peak`),\n    `Weekday evening peak` = sum(`Weekday evening peak`),\n    `Weekend/PH morning peak` = sum(`Weekend/PH morning peak`),\n    `Weekend/PH evening peak` = sum(`Weekend/PH evening peak`)\n  ) %>%\n  replace(is.na(.), 0) %>%\n  ungroup()\n\n\nStep 3: Create Spatial Polygon dataframe by joining\n\nleft_join the new busod_08_stops aspatial dataframe to busod_08_hex hexagon geospatial layer by hex_id to add attributes to the spatial polygon dataframe\nfilter out the hexagons with no bus stops\n\nOutput: Spatial Polygon Dataframe\n\n\nbusod_08_hex <- busod_08_hex %>%\n  left_join(busod_08_stops,\n            by = \"hex_id\"\n  ) %>%\n  replace(is.na(.), 0)\n\nbustraffic08 <- filter(busod_08_hex,\n                       n_busstops > 0)\n\n\n\n\nThe following map shows each area coloured by bus stop density:\n\n\ncode block\ntmap_mode(\"view\")\n\nbustraffic08_map <- tm_basemap(\"CartoDB.Positron\") +\n  tm_shape(bustraffic08) +\n  tm_fill(\n    col = \"n_busstops\",\n    palette = \"PuBu\",\n    style = \"cont\",\n    id = \"hex_id\",\n    popup.vars = c(\"No. of bus stops: \" = \"n_busstops\",\n                   \"Bus Stop codes: \" = \"busstop_codes\"),\n    title = \" \"\n  ) +\n  tm_layout(\n    # Set legend.show to FALSE to hide the legend\n    legend.show = FALSE\n  )\n\nbustraffic08_map"
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#continuous-intervals",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#continuous-intervals",
    "title": "Take-home Ex 1",
    "section": "7.1 Continuous Intervals",
    "text": "7.1 Continuous Intervals\nstyle = \"cont\" argument is specified to fill the hexagons along a continuous colour scale according to passenger trip volume.\n\n\ncode block\nbus08_facet <- tm_shape(bustraffic08) +\n  tm_fill(c(\"Weekday morning peak\", \"Weekday evening peak\"),\n          palette = \"Reds\",\n          style = \"cont\",\n          alpha = .7,\n          popup.vars = c(\"No. of bus stops: \" = \"n_busstops\",\n                         \"Weekday Morning traffic: \" = \"Weekday morning peak\",\n                         \"Weekday Evening traffic: \" = \"Weekday evening peak\",\n                         \"Bus Stop codes: \" = \"busstop_codes\")\n  ) +\n  tm_scale_bar(width = 0.15) +\n  tm_layout(\n    title = c(\"Weekday morning peak\", \"Weekday evening peak\"),\n    panel.labels = c(\"Weekday morning peak\", \"Weekday evening peak\")\n  ) +\n  tm_facets(\n    sync = TRUE, \n    ncol = 1\n  )\n\nbus08_facet"
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#binned-by-quantiles",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#binned-by-quantiles",
    "title": "Take-home Ex 1",
    "section": "7.2 Binned by Quantiles",
    "text": "7.2 Binned by Quantiles\nstyle = \"quantile\" argument is used categorically bin the variable based on quantile values. The traffic appears far more congested using this binning method compared to the continuous scale, and is largely due to the highly skewed distribution of the variable. It is thus not a conclusive way of determining which areas are true hot spots based on volume of trips.\n\n\ncode block\nbus08_facet2 <- tm_shape(bustraffic08) +\n  tm_fill(c(\"Weekday morning peak\", \"Weekday evening peak\"),\n          palette = \"Reds\",\n          style = \"quantile\",\n          alpha = .7,\n          popup.vars = c(\"No. of bus stops: \" = \"n_busstops\",\n                         \"Weekday Morning traffic: \" = \"Weekday morning peak\",\n                         \"Weekday Evening traffic: \" = \"Weekday evening peak\",\n                         \"Bus Stop codes: \" = \"busstop_codes\")\n  ) +\n  tm_scale_bar(width = 0.15) +\n  tm_layout(\n    title = c(\"Weekday morning peak\", \"Weekday evening peak\"),\n    panel.labels = c(\"Weekday morning peak\", \"Weekday evening peak\")\n  ) +\n  tm_facets(\n    sync = TRUE, \n    ncol = 1\n  )\n\nbus08_facet2"
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#binned-by-jenks-algorithm",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#binned-by-jenks-algorithm",
    "title": "Take-home Ex 1",
    "section": "7.3 Binned by jenks algorithm",
    "text": "7.3 Binned by jenks algorithm\nstyle = \"jenks\" argument is used to ‘cluster’ groups with similar values and maximize the difference between each group. It is based on the Jenks natural breaks classification method, a data clustering algorithm used to determine the best arrangement of values and assign them into ‘classes’. This is chosen over equal or quantile binning due to the wide range of values present in the distribution.\n\n\ncode block\nbus08_facet3 <- tm_shape(bustraffic08) +\n  tm_fill(c(\"Weekday morning peak\", \"Weekday evening peak\"),\n          palette = \"Reds\",\n          style = \"jenks\",\n          alpha = .7,\n          popup.vars = c(\"No. of bus stops: \" = \"n_busstops\",\n                         \"Weekday Morning traffic: \" = \"Weekday morning peak\",\n                         \"Weekday Evening traffic: \" = \"Weekday evening peak\",\n                         \"Bus Stop codes: \" = \"busstop_codes\")\n  ) +\n  tm_scale_bar(width = 0.15) +\n  tm_layout(\n    title = c(\"Weekday morning peak\", \"Weekday evening peak\"),\n    panel.labels = c(\"Weekday morning peak\", \"Weekday evening peak\")\n  ) +\n  tm_facets(\n    sync = TRUE, \n    ncol = 1\n  )\n\nbus08_facet3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.\n\nWhile the continuous colour-scale map showed more isolated pockets of areas as potential hotspots, the quantile binning and jenks algorithm revealed a more clustered distribution of hotspot areas.\n\nComparing the maps, several Areas have been identified as Weekday Peak high passenger volume hotspots. These are mostly areas encompassing an MRT Station and/or Bus Interchange, and are listed out by hexagon ID below:\n\nhex_id 2411: Woodlands MRT Stationhex_id 3239: Ang Mo Kio MRT Station/ Bus Interchangehex_id 4349: Bedok MRT station/ Bus Interchangehex_id 4018: Punggol Roadhex_id 2054: Clementi MRT Station\n\n\n\nhex_2411 <- busstop %>%\n  filter(\n    origin_pt_code %in% c(\"46649\",\"46339\",\"46009\",\"46321\",\"46641\",\"46639\",\"46631\",\"46329\")\n  ) %>%\n  st_set_geometry(NULL) %>%\n  select(\n    origin_pt_code, loc_desc\n  )\n\nDT::datatable(hex_2411)\n\n\n\n\n\n\n\n\n\nhex_3239 <- busstop %>%\n  filter(\n    origin_pt_code %in% c(\"54247\",\"54339\",\"54391\",\"54261\",\"54009\",\"54399\")\n  ) %>%\n  st_set_geometry(NULL) %>%\n  select(\n    origin_pt_code, loc_desc\n  )\n\nDT::datatable(hex_3239)\n\n\n\n\n\n\n\n\n\nhex_4349 <- busstop %>%\n  filter(\n    origin_pt_code %in% c(\"84031\",\"84139\",\"84131\",\"84009\",\"84039\")\n  ) %>%\n  st_set_geometry(NULL) %>%\n  select(\n    origin_pt_code, loc_desc\n  )\n\nDT::datatable(hex_4349)\n\n\n\n\n\n\n\n\n\nhex_4018 <- busstop %>%\n  filter(\n    origin_pt_code %in% c(\"65079\",\"65191\",\"65199\",\"65071\")\n  ) %>%\n  st_set_geometry(NULL) %>%\n  select(\n    origin_pt_code, loc_desc\n  )\n\nDT::datatable(hex_4018)\n\n\n\n\n\n\n\n\n\nhex_2054 <- busstop %>%\n  filter(\n    origin_pt_code %in% c(\"20019\",\"17179\",\"17171\")\n  ) %>%\n  st_set_geometry(NULL) %>%\n  select(\n    origin_pt_code, loc_desc\n  )\n\nDT::datatable(hex_2054)"
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#continuous-intervals-1",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#continuous-intervals-1",
    "title": "Take-home Ex 1",
    "section": "8.1 Continuous Intervals",
    "text": "8.1 Continuous Intervals\n\n\ncode block\nph_bus08_facet <- tm_shape(bustraffic08) +\n  tm_fill(c(\"Weekend/PH morning peak\", \"Weekend/PH evening peak\"),\n          palette = \"Purples\",\n          style = \"cont\",\n          alpha = .7,\n          popup.vars = c(\"No. of bus stops: \" = \"n_busstops\",\n                         \"Weekend/PH Morning traffic: \" = \"Weekday morning peak\",\n                         \"Weekend/PH Evening traffic: \" = \"Weekday evening peak\",\n                         \"Bus Stop codes: \" = \"busstop_codes\")\n  ) +\n  tm_scale_bar(width = 0.15) +\n  tm_layout(\n    title = c(\"Weekend/PH morning peak\", \"Weekend/PH evening peak\")\n  ) +\n  tm_facets(\n    sync = TRUE, \n    ncol = 1\n  )\n\nph_bus08_facet"
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#binned-by-quantile",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#binned-by-quantile",
    "title": "Take-home Ex 1",
    "section": "8.2 Binned by quantile",
    "text": "8.2 Binned by quantile\n\n\ncode block\ntmap_mode(\"view\")\n\nph_bus08_facet2 <- tm_shape(bustraffic08) +\n  tm_fill(c(\"Weekend/PH morning peak\", \"Weekend/PH evening peak\"),\n          palette = \"Purples\",\n          style = \"quantile\",\n          alpha = .7,\n          popup.vars = c(\"No. of bus stops: \" = \"n_busstops\",\n                         \"Weekend/PH Morning traffic: \" = \"Weekday morning peak\",\n                         \"Weekend/PH Evening traffic: \" = \"Weekday evening peak\",\n                         \"Bus Stop codes: \" = \"busstop_codes\")\n  ) +\n  tm_scale_bar(width = 0.15) +\n  tm_layout(\n    title = c(\"Weekend/PH morning peak\", \"Weekend/PH evening peak\")\n  ) +\n  tm_facets(\n    sync = TRUE, \n    ncol = 1\n  )\n\nph_bus08_facet2"
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#binned-by-jenks-algorithm-1",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#binned-by-jenks-algorithm-1",
    "title": "Take-home Ex 1",
    "section": "8.3 Binned by jenks algorithm",
    "text": "8.3 Binned by jenks algorithm\n\n\ncode block\nph_bus08_facet3 <- tm_shape(bustraffic08) +\n  tm_fill(c(\"Weekend/PH morning peak\", \"Weekend/PH evening peak\"),\n          palette = \"Purples\",\n          style = \"jenks\",\n          alpha = .7,\n          popup.vars = c(\"No. of bus stops: \" = \"n_busstops\",\n                         \"Weekend/PH Morning traffic: \" = \"Weekday morning peak\",\n                         \"Weekend/PH Evening traffic: \" = \"Weekday evening peak\",\n                         \"Bus Stop codes: \" = \"busstop_codes\")\n  ) +\n  tm_scale_bar(width = 0.15) +\n  tm_layout(\n    title = c(\"Weekend/PH morning peak\", \"Weekend/PH evening peak\")\n  ) +\n  tm_facets(\n    sync = TRUE, \n    ncol = 1\n  )\n\nph_bus08_facet3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe ‘clustered’ maps above reveal denser hotspots in the north and central regions compared to Weekday peak periods. However, similarly high passenger traffic was recording in specific areas, identified and listed below:\n\nhex_id 3292: Bugis & Bencoolen MRT stationhex_id 3014: Orchard MRT Stationhex_id 2135: Johor Bahru Checkpoint\n\n\n\nhex_3292 <- busstop %>%\n  filter(\n    origin_pt_code %in% c(\"01013\",\"01119\",\"01112\",\"01019\",\"01012\",\"04029\",\"07569\",\"07561\")\n  ) %>%\n  st_set_geometry(NULL) %>%\n  select(\n    origin_pt_code, loc_desc\n  )\n\nDT::datatable(hex_3292)\n\n\n\n\n\n\n\n\n\nhex_3014 <- busstop %>%\n  filter(\n    origin_pt_code %in% c(\"09011\",\"09022\",\"09048\",\"09047\",\"09023\")\n  ) %>%\n  st_set_geometry(NULL) %>%\n  select(\n    origin_pt_code, loc_desc\n  )\n\nDT::datatable(hex_3014)\n\n\n\n\n\n\n\n\n\nhex_2135 <- busstop %>%\n  filter(\n    origin_pt_code %in% c(\"46211\",\"46219\")\n  ) %>%\n  st_set_geometry(NULL) %>%\n  select(\n    origin_pt_code, loc_desc\n  )\n\nDT::datatable(hex_2135)\n\n\n\n\n\n\n\n\n\n\nWeekday vs Weekend/PH Peak Periods\n\nKey hotspot areas were similar, especially in larger heartland areas with busy MRT stations and bus interchanges\nJenks algorithm revealed smaller ‘clusters’ of hot spots during weekend peak periods compared to weekday peak periods, although both day types had similar highest passenger traffic areas\nThe visualised distribution of passenger volume using continuous scale versus binned intervals reveals different patterns, and further investigation needs to be conducted to determine if those areas are truly spatially clustered or are outliers in the overall distribution"
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#computing-local-morans-i-statistics",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#computing-local-morans-i-statistics",
    "title": "Take-home Ex 1",
    "section": "9.1 Computing local Moran’s I statistics",
    "text": "9.1 Computing local Moran’s I statistics\n\nStep 1: Compute spatial weight matrixStep 2: Monte Carlo simulation of Local Moran’s I\n\n\nThe code chunk below performs the following actions:\n\nmutate creates 2 new columns, nb and wt\nnb stores the Queen’c contiguity weight matrix, computed using st_contiguity\nwt stores the row-standardised weight matrix\n\n\nwm08 <- busod_08_hex %>%\n  mutate(nb = st_contiguity(geometry),\n         wt = st_weights(nb,\n                         style = \"W\"),\n         .before = 1)\n\n\n\nThe following code runs a Monte Carlo simulation of Local Moran’s I on weekday morning peak traffic.This function returns the following values as separate columns:\n\nii (Moran’s I for each observation): the local spatial autocorrelation for each hexagon. +ve values suggest clustering while -ve values suggest dispersion.\nE_ii (Expected Moran’s I for each observation): the expected value of Moran’s I under spatial randomness, based on the assumption that there is no spatial autocorrelation.\nvar_ii (Variance of Ii): the variability of the Moran’s I values across observations\nz_ii (Z-score): A standardized score that measures how many standard deviations an observed Moran’s I deviates from the expected Moran’s I. +ve scores indicate higher correlation than expected\np_ii (p-value): the probability of observing the given Moran’s I under the assumption of spatial randomness. A p-value less than the chosen significance level (e.g., 0.05) suggests that the spatial pattern is statistically significant.\np_ii_sim (simulated p-value): the p-value based on monte carlo simulation of 1000 trials\nmean, median, pysal: the cluster category based spatial patterns\n\n\n# set seed to ensure that results from simulation are reproducible\nset.seed(8888)\n\n# Weekday morning\nlisa08_wdm <- wm08 %>%\n  mutate(local_moran = local_moran(`Weekday morning peak`,\n                                   nb,\n                                   wt,\n                                   nsim = 999),\n         .before = 1) %>%\n  unnest(local_moran) %>%\n  # only retain hexagons with a bus stop\n  filter(n_busstops > 0)\n\n# Weekday evening\nlisa08_wde <- wm08 %>%\n  mutate(local_moran = local_moran(`Weekday evening peak`,\n                                   nb,\n                                   wt,\n                                   nsim = 999),\n         .before = 1) %>%\n  unnest(local_moran) %>%\n  # only retain hexagons with a bus stop\n  filter(n_busstops > 0)"
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#step-3-visualise-i-statistic-and-p-value",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#step-3-visualise-i-statistic-and-p-value",
    "title": "Take-home Ex 1",
    "section": "9.2 Step 3: Visualise I statistic and p-value",
    "text": "9.2 Step 3: Visualise I statistic and p-value\n\nAn area could be identified as a cluster or an outlier based on I statistic value and p-value:\n\noutlier: significant and negative i value (area is associated with relatively low i values of neighbors)\ncluster: significant and positive i value (area is associated with relatively high i values of neighbors)\n\n\n\n\ncode block\n# Set map to static\ntmap_mode(\"plot\")\n\n# weekday morning moran I values\nmap_wdm_moran08 <- tm_shape(lisa08_wdm) +\n  tm_fill(\n    col = \"ii\",\n    palette = \"OrRd\",\n    style = \"pretty\",\n    title = \"Local Moran's I\"\n  ) +\n  tm_layout(main.title = \"Weekday Morning Peak Traffic\",\n            main.title.size = 1,\n            main.title.position = \"center\",\n            legend.position = c(\"left\", \"top\"),\n            legend.height = .6,\n            legend.width = .2,\n            frame = FALSE\n  )\n\n# weekday morning p-values\nmap_wdm_pvalue <- tm_shape(lisa08_wdm) +\n  tm_fill(\n    col = \"p_ii_sim\",\n    palette = \"-BuGn\",\n    alpha = .8,\n    breaks = c(0, 0.001, 0.01, 0.05, 1),\n    labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not Sig\"),\n    title = \"p-value\"\n  ) + \n  tm_layout(main.title = \"p-values of Local Moran's I\",\n            main.title.size = 0.8,\n            main.title.position = \"center\",\n            legend.position = c(\"right\", \"top\"),\n            legend.height = .5,\n            legend.width = .2,\n            frame = FALSE\n  )\n\n# weekday evening moran I values\nmap_wde_moran08 <- tm_shape(lisa08_wde) +\n  tm_fill(\n    col = \"ii\",\n    palette = \"OrRd\",\n    style = \"pretty\",\n    title = \"Local Moran's I\"\n  ) +\n  tm_layout(main.title = \"Weekday Evening Peak Traffic\",\n            main.title.size = 1,\n            main.title.position = \"center\",\n            legend.position = c(\"left\", \"top\"),\n            legend.height = .6,\n            legend.width = .2,\n            frame = FALSE\n  )\n\n# weekday evening p-values\nmap_wde_pvalue <- tm_shape(lisa08_wde) +\n  tm_fill(\n    col = \"p_ii_sim\",\n    palette = \"-BuGn\",\n    alpha = .8,\n    breaks = c(0, 0.001, 0.01, 0.05, 1),\n    labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not Sig\"),\n    title = \"p-value\"\n  ) + \n  tm_layout(main.title = \"p-values of Local Moran's I\",\n            main.title.size = 0.8,\n            main.title.position = \"center\",\n            legend.position = c(\"right\", \"top\"),\n            legend.height = .5,\n            legend.width = .2,\n            frame = FALSE\n  )\n\ntmap_arrange(map_wdm_moran08, map_wdm_pvalue,\n             map_wde_moran08, map_wde_pvalue,\n             ncol = 2)\n\n\n\n\n\n\n\ncode block\nset.seed(8888)\n\n# Compute local moran's I simulation for weekend/PH morning peak\nlisa08_phm <- wm08 %>%\n  mutate(local_moran = local_moran(`Weekend/PH morning peak`,\n                                   nb,\n                                   wt,\n                                   nsim = 999),\n         .before = 1) %>%\n  unnest(local_moran) %>%\n  # only retain hexagons with a bus stop\n  filter(n_busstops > 0)\n\n# Compute local moran's I simulation for weekend/PH evening peak\nlisa08_phe <- wm08 %>%\n  mutate(local_moran = local_moran(`Weekend/PH evening peak`,\n                                   nb,\n                                   wt,\n                                   nsim = 999),\n         .before = 1) %>%\n  unnest(local_moran) %>%\n  # only retain hexagons with a bus stop\n  filter(n_busstops > 0)\n\n\n\n\ncode block\n# Set map to static\ntmap_mode(\"plot\")\n\n# weekend/PH  moran I values\nmap_phm_moran08 <- tm_shape(lisa08_phm) +\n  tm_fill(\n    col = \"ii\",\n    palette = \"RdPu\",\n    style = \"pretty\",\n    title = \"Local Moran's I\"\n  ) +\n  tm_layout(main.title = \"Weekend/PH Morning Peak Traffic\",\n            main.title.size = 1,\n            main.title.position = \"center\",\n            legend.position = c(\"left\", \"top\"),\n            legend.height = .6,\n            legend.width = .2,\n            frame = FALSE\n  )\n\n# weekend/PH  p-values\nmap_phm_pvalue <- tm_shape(lisa08_phm) +\n  tm_fill(\n    col = \"p_ii_sim\",\n    palette = \"-BuGn\",\n    alpha = .8,\n    breaks = c(0, 0.001, 0.01, 0.05, 1),\n    labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not Sig\"),\n    title = \"p-value\"\n  ) + \n  tm_layout(main.title = \"p-values of Local Moran's I\",\n            main.title.size = 0.8,\n            main.title.position = \"center\",\n            legend.position = c(\"right\", \"top\"),\n            legend.height = .5,\n            legend.width = .2,\n            frame = FALSE\n  )\n\n# weekend/PH moran I values\nmap_phe_moran08 <- tm_shape(lisa08_phe) +\n  tm_fill(\n    col = \"ii\",\n    palette = \"RdPu\",\n    style = \"pretty\",\n    title = \"Local Moran's I\"\n  ) +\n  tm_layout(main.title = \"Weekend/PHEvening Peak Traffic\",\n            main.title.size = 1,\n            main.title.position = \"center\",\n            legend.position = c(\"left\", \"top\"),\n            legend.height = .6,\n            legend.width = .2,\n            frame = FALSE\n  )\n\n# weekend/PH evening p-values\nmap_phe_pvalue <- tm_shape(lisa08_phe) +\n  tm_fill(\n    col = \"p_ii_sim\",\n    palette = \"-BuGn\",\n    alpha = .8,\n    breaks = c(0, 0.001, 0.01, 0.05, 1),\n    labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not Sig\"),\n    title = \"p-value\"\n  ) + \n  tm_layout(main.title = \"p-values of Local Moran's I\",\n            main.title.size = 0.8,\n            main.title.position = \"center\",\n            legend.position = c(\"right\", \"top\"),\n            legend.height = .5,\n            legend.width = .2,\n            frame = FALSE\n  )\n\ntmap_arrange(map_phm_moran08, map_phm_pvalue,\n             map_phe_moran08, map_phe_pvalue,\n             ncol = 2)\n\n\n\n\n\nFrom comparing the maps above, we can detect multiple clusters that are significant and possess high, positive Local Moran’s I values. In general, there are more clusters during Weekday morning peak hours compared to evening, while the number of clusters during Weekends or Public holiday morning and evening peak periods do not show large variation. To visualise the extent of the spatial clustering, we look at the mean Local Moran’s I cluster quadrants, computed as variable mean."
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#visualising-local-moran-clusters",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#visualising-local-moran-clusters",
    "title": "Take-home Ex 1",
    "section": "9.3 Visualising Local Moran Clusters",
    "text": "9.3 Visualising Local Moran Clusters\nThe spatial clusters are visualised in the map below, with one showing all values and the other displaying only statistically significant clusters (p-value <0.05):\n\n\ncode block\ncolors <- c(\"#4d5887\", \"#B1EDE8\", \"#f5bc5f\", \"salmon\")\n\ntmap_mode(\"plot\")\n\nmean_wdm <- lisa08_wdm  %>%\n  filter(p_ii_sim < 0.05)\n\n# All significant values\nplot_wdm_all <- \n  tm_shape(lisa08_wdm) +\n  tm_fill(\n    col = \"mean\",\n    style = \"cat\",\n    palette = colors\n  ) +\n  tm_layout(\n    main.title = \"Local Moran Clusters (All)\",\n    main.title.size = .8,\n    main.title.position = \"center\",\n    frame = FALSE)\n\nplot_wdm_mean <- \n  tm_shape(lisa08_wdm) +\n  tm_polygons(\n    col = \"#ffffff\"\n  ) +\n  tm_borders(col = NA) +\n  tm_shape(mean_wdm) +\n  tm_fill(\n    col = \"mean\",\n    style = \"cat\",\n    palette = colors\n  ) +\n  tm_layout(\n    main.title = \"Local Moran Clusters (Significant)\",\n    main.title.size = .8,\n    main.title.position = \"center\",\n    frame = FALSE)\n\ntmap_arrange(plot_wdm_all, plot_wdm_mean,\n             ncol = 2)\n\n\n\n\n\nWe can deduce that there are 2 main types of statistically significant clusters present during Weekday Morning Peak Periods:\n\nHigh-High clusters suggest spatial autocorrelation, indicating that areas with similar attribute values are clustered together to form possible hot spots for passenger congestion\nLow-High clusters suggest spatial outliers, where areas with dissimilar attribute values are located near each other. Passenger volume is much lower and these ares are not flagged for possible congestion."
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#fa-sun-weekday-morning-peak-periods",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#fa-sun-weekday-morning-peak-periods",
    "title": "Take-home Ex 1",
    "section": "9.4  Weekday Morning Peak Periods",
    "text": "9.4  Weekday Morning Peak Periods\n\n\ncode block\ntmap_mode(\"view\")\n\nplot_wdm <- tm_basemap(\"OneMapSG.Grey\") +\n  tm_shape(mean_wdm) +\n  tm_fill(\n    c(\"Weekday morning peak\", \"mean\"),\n    alpha = .7,\n    title = c(\"Passenger Volume\", \"Cluster\"),\n    popup.vars = c(\"Hex ID: \" = \"hex_id\", \n                   \"Cluster\" = \"mean\",\n                   \"No. of bus stops: \" = \"n_busstops\",\n                   \"Weekday Morning traffic: \" = \"Weekday morning peak\",\n                   \"Bus Stop codes: \" = \"busstop_codes\")\n  ) +\n  tm_facets(\n    sync = TRUE, \n    ncol = 1\n  ) +\n  tm_layout(\n    title = \"Weekday Morning Peak Traffic\",\n    title.size = 1\n  )\n\nplot_wdm"
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#fa-moon-weekday-evening-peak-periods",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#fa-moon-weekday-evening-peak-periods",
    "title": "Take-home Ex 1",
    "section": "9.5  Weekday Evening Peak Periods",
    "text": "9.5  Weekday Evening Peak Periods\n\n\ncode block\nmean_wde <- lisa08_wde  %>%\n  filter(p_ii_sim < 0.05)\n\nplot_wde <- tm_basemap(\"OneMapSG.Night\") +\n  tm_shape(mean_wde) +\n  tm_fill(\n    c(\"Weekday evening peak\", \"mean\"),\n    alpha = .7,\n    title = c(\"Passenger Volume\", \"Cluster\"),\n    popup.vars = c(\"Hex ID: \" = \"hex_id\", \n                   \"Cluster\" = \"mean\",\n                   \"No. of bus stops: \" = \"n_busstops\",\n                   \"Weekday Morning traffic: \" = \"Weekday morning peak\",\n                   \"Bus Stop codes: \" = \"busstop_codes\")\n  ) +\n  tm_facets(\n    sync = TRUE, \n    ncol = 1\n  ) +\n  tm_layout(\n    title = \"Weekday Evening Peak Traffic\",\n    title.size = 1\n  )\n\nplot_wde"
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#fa-sun-weekendpublic-holiday-morning-peak-periods",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#fa-sun-weekendpublic-holiday-morning-peak-periods",
    "title": "Take-home Ex 1",
    "section": "9.6  Weekend/Public Holiday Morning Peak Periods",
    "text": "9.6  Weekend/Public Holiday Morning Peak Periods\n\n\ncode block\nmean_phm <- lisa08_phm  %>%\n  filter(p_ii_sim < 0.05)\n\ntmap_mode(\"view\")\n\nplot_phm <- tm_basemap(\"OneMapSG.Grey\") +\n  tm_shape(mean_phm) +\n  tm_fill(\n    c(\"Weekend/PH morning peak\", \"mean\"),\n    alpha = .7,\n    title = c(\"Passenger Volume\", \"Cluster\"),\n    popup.vars = c(\"Hex ID: \" = \"hex_id\", \n                   \"Cluster\" = \"mean\",\n                   \"No. of bus stops: \" = \"n_busstops\",\n                   \"Weekday Morning traffic: \" = \"Weekday morning peak\",\n                   \"Bus Stop codes: \" = \"busstop_codes\")\n  ) +\n  tm_facets(\n    sync = TRUE, \n    ncol = 1\n  ) +\n  tm_layout(\n    title = \"Weekend/PH Morning Peak Traffic\",\n    title.size = 1\n  )\n\nplot_phm"
  },
  {
    "objectID": "Take-home_Ex/the1/Take-home_ex1.html#fa-moon-weekendpublic-holiday-evening-peak-periods",
    "href": "Take-home_Ex/the1/Take-home_ex1.html#fa-moon-weekendpublic-holiday-evening-peak-periods",
    "title": "Take-home Ex 1",
    "section": "9.7  Weekend/Public Holiday Evening Peak Periods",
    "text": "9.7  Weekend/Public Holiday Evening Peak Periods\n\n\ncode block\nmean_phe <- lisa08_phe  %>%\n  filter(p_ii_sim < 0.05)\n\ntmap_mode(\"view\")\n\nplot_phe <- tm_basemap(\"OneMapSG.Night\") +\n  tm_shape(mean_phe) +\n  tm_fill(\n    c(\"Weekend/PH evening peak\", \"mean\"),\n    alpha = .7,\n    title = c(\"Passenger Volume\", \"Cluster\"),\n    popup.vars = c(\"Hex ID: \" = \"hex_id\", \n                   \"Cluster\" = \"mean\",\n                   \"No. of bus stops: \" = \"n_busstops\",\n                   \"Weekday Morning traffic: \" = \"Weekday morning peak\",\n                   \"Bus Stop codes: \" = \"busstop_codes\")\n  ) +\n  tm_facets(\n    sync = TRUE, \n    ncol = 1\n  ) +\n  tm_layout(\n    title = \"Weekend/PH Evening Peak Traffic\",\n    title.size = 1\n  )\n\nplot_phe\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere are several key insights to be drawn from the maps presented above:\n\nWeekday Morning and Evening Peak Timings have similar hot spot clusters, concentrated around MRT Stations of residential neighbourhoods such as Woodlands, Yishun, Ang Mo Kio, etc.\nHowever, Weekday Evening Peak Periods reveal clusters of high traffic in the Central, CBD area as well. As the aggregation of trips is based on point of origin, this shows that the general traffic flows outward from the CBD area after working hours.\nWeekend/Public Holiday Morning and Evening Peak traffic have similar high-high clusters as well, even though the absolute volume of passenger trips is lower. This could be due to more people driving rather than commuting via bus.\nHot spot clusters around residential neighborhoods’ MRT stations persists on Weekends/PH as well, suggesting a high population density in those areas."
  }
]